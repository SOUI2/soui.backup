#pragma once
// Start of SOUI namespace section
namespace SOUI
{
    class SWindow;

/*!
\brief
    Base class used as the argument to all subscribers Event object.

    The base EventArgs class does not contain any useful information, it is intended
    to be specialised for each type of event that can be generated by objects within
    the system.  The use of this base class allows all event subscribers to have the
    same function signature.

    The \a handled field is used to signal whether an event was actually handled or not.  While
    the event system does not look at this value, code at a higher level can use it to determine
    how far to propagate an event.
*/
class SOUI_EXP EventArgs
{
public:
    /*************************************************************************
        Construction
    *************************************************************************/
    EventArgs(LPSNMHDR pnms,SWindow *pSender) 
        : handled(0)
        , m_pnms(pnms)
        , m_pSender(pSender)
    {}
    virtual ~EventArgs(void) {}

    LPSNMHDR m_pnms;

    SWindow *m_pSender;
    /*************************************************************************
        Data members
    *************************************************************************/
    //! handlers should increment this if they handled the event.
    UINT handled;
};

enum _SLOTTYPE{SLOT_FUN,SLOT_MEMBER,SLOT_USER};
/*!
\brief
    Defines abstract interface which will be used when constructing various
    functor objects that bind slots to signals (or in CEGUI terms, handlers to
    events).
*/
class SOUI_EXP SlotFunctorBase
{
public:
    virtual ~SlotFunctorBase() {};
    virtual bool operator()(SWindow * pSender,LPSNMHDR pNmhdr) = 0;
    virtual SlotFunctorBase* Clone() const =0;
    virtual bool Equal(const SlotFunctorBase & sour)const  =0;
    virtual UINT GetSlotType() const  =0;
};

/*!
\brief
    Slot functor class that calls back via a free function pointer.
*/
class SOUI_EXP FreeFunctionSlot : public SlotFunctorBase
{
public:
    //! Slot function type.
    typedef bool (SlotFunction)(SWindow * ,LPSNMHDR );

    FreeFunctionSlot(SlotFunction* func) :
        d_function(func)
    {}

    virtual bool operator()(SWindow * pSender,LPSNMHDR pNmhdr)
    {
        return d_function(pSender,pNmhdr);
    }

    virtual SlotFunctorBase* Clone() const 
    {
        return new FreeFunctionSlot(d_function);
    }

    virtual bool Equal(const SlotFunctorBase & sour)const 
    {
        if(sour.GetSlotType()!=SLOT_FUN) return false;
        const FreeFunctionSlot *psour=static_cast<const FreeFunctionSlot*>(&sour);
        ASSERT(psour);
        return psour->d_function==d_function;
    }

    virtual UINT GetSlotType() const {return SLOT_FUN;}

private:
    SlotFunction* d_function;
};

/*!
\brief
    Slot template class that creates a functor that calls back via a class
    member function.
*/
template<typename T>
class MemberFunctionSlot : public SlotFunctorBase
{
public:
    //! Member function slot type.
    typedef bool(T::*MemberFunctionType)(SWindow * ,LPSNMHDR );

    MemberFunctionSlot(MemberFunctionType func, T* obj) :
        d_function(func),
        d_object(obj)
    {}

    virtual bool operator()(SWindow * pSender,LPSNMHDR pNmhdr)
    {
        return (d_object->*d_function)(pSender,pNmhdr);
    }

    virtual SlotFunctorBase* Clone() const 
    {
        return new MemberFunctionSlot(d_function,d_object);
    }

    virtual bool Equal(const SlotFunctorBase & sour)const 
    {
        if(sour.GetSlotType()!=SLOT_MEMBER) return false;
        const MemberFunctionSlot *psour=static_cast<const MemberFunctionSlot*>(&sour);
        ASSERT(psour);
        return psour->d_function==d_function && psour->d_object==d_object;
    }

    virtual UINT GetSlotType()const {return SLOT_MEMBER;}

private:
    MemberFunctionType d_function;
    T* d_object;
};

template <class T>
MemberFunctionSlot<T> Subscriber( bool (T::* pFn)(SWindow * ,LPSNMHDR ), T* pObject)
{
    return MemberFunctionSlot<T>(pFn,pObject);
}

inline FreeFunctionSlot Subscriber(bool (*pFn)(SWindow * ,LPSNMHDR ))
{
    return FreeFunctionSlot(pFn); 
}

} // End of  CEGUI namespace section