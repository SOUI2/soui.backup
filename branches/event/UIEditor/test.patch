Index: colorpicker/ColourPopup.cpp
===================================================================
--- colorpicker/ColourPopup.cpp	(revision 0)
+++ colorpicker/ColourPopup.cpp	(working copy)
@@ -0,0 +1,844 @@
+// ColourPopup.cpp : implementation file
+//
+// Written by Chris Maunder (chrismaunder@codeguru.com)
+// Extended by Alexander Bischofberger (bischofb@informatik.tu-muenchen.de)
+// Copyright (c) 1998.
+//
+// Updated 30 May 1998 to allow any number of colours, and to
+//                     make the appearance closer to Office 97. 
+//                     Also added "Default" text area.         (CJM)
+//
+//         13 June 1998 Fixed change of focus bug (CJM)
+//         30 June 1998 Fixed bug caused by focus bug fix (D'oh!!)
+//                      Solution suggested by Paul Wilkerson.
+//
+// ColourPopup is a helper class for the colour picker control
+// CColourPicker. Check out the header file or the accompanying 
+// HTML doc file for details.
+//
+// This code may be used in compiled form in any way you desire. This
+// file may be redistributed unmodified by any means PROVIDING it is 
+// not sold for profit without the authors written consent, and 
+// providing that this notice and the authors name is included. 
+//
+// This file is provided "as is" with no expressed or implied warranty.
+// The author accepts no liability if it causes any damage to you or your
+// computer whatsoever. It's free, so don't hassle me about it.
+//
+// Expect bugs.
+// 
+// Please use and enjoy. Please let me know of any bugs/mods/improvements 
+// that you have found/implemented and I will fix/incorporate them into this
+// file. 
+
+#include "stdafx.h"
+#include <math.h>
+#include "ColourPopup.h"
+
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
+#endif
+
+#define DEFAULT_BOX_VALUE -3
+#define CUSTOM_BOX_VALUE  -2
+#define INVALID_COLOUR    -1
+
+#define MAX_COLOURS      100
+
+
+namespace DuiEngine
+{
+
+CColourPopup::ColourTableEntry CColourPopup::m_crColours[] = 
+{
+    { RGB(0x00, 0x00, 0x00),    _T("Black")             },
+    { RGB(0xA5, 0x2A, 0x00),    _T("Brown")             },
+    { RGB(0x00, 0x40, 0x40),    _T("Dark Olive Green")  },
+    { RGB(0x00, 0x55, 0x00),    _T("Dark Green")        },
+    { RGB(0x00, 0x00, 0x5E),    _T("Dark Teal")         },
+    { RGB(0x00, 0x00, 0x8B),    _T("Dark blue")         },
+    { RGB(0x4B, 0x00, 0x82),    _T("Indigo")            },
+    { RGB(0x28, 0x28, 0x28),    _T("Dark grey")         },
+
+    { RGB(0x8B, 0x00, 0x00),    _T("Dark red")          },
+    { RGB(0xFF, 0x68, 0x20),    _T("Orange")            },
+    { RGB(0x8B, 0x8B, 0x00),    _T("Dark yellow")       },
+    { RGB(0x00, 0x93, 0x00),    _T("Green")             },
+    { RGB(0x38, 0x8E, 0x8E),    _T("Teal")              },
+    { RGB(0x00, 0x00, 0xFF),    _T("Blue")              },
+    { RGB(0x7B, 0x7B, 0xC0),    _T("Blue-grey")         },
+    { RGB(0x66, 0x66, 0x66),    _T("Grey - 40")         },
+
+    { RGB(0xFF, 0x00, 0x00),    _T("Red")               },
+    { RGB(0xFF, 0xAD, 0x5B),    _T("Light orange")      },
+    { RGB(0x32, 0xCD, 0x32),    _T("Lime")              }, 
+    { RGB(0x3C, 0xB3, 0x71),    _T("Sea green")         },
+    { RGB(0x7F, 0xFF, 0xD4),    _T("Aqua")              },
+    { RGB(0x7D, 0x9E, 0xC0),    _T("Light blue")        },
+    { RGB(0x80, 0x00, 0x80),    _T("Violet")            },
+    { RGB(0x7F, 0x7F, 0x7F),    _T("Grey - 50")         },
+
+    { RGB(0xFF, 0xC0, 0xCB),    _T("Pink")              },
+    { RGB(0xFF, 0xD7, 0x00),    _T("Gold")              },
+    { RGB(0xFF, 0xFF, 0x00),    _T("Yellow")            },    
+    { RGB(0x00, 0xFF, 0x00),    _T("Bright green")      },
+    { RGB(0x40, 0xE0, 0xD0),    _T("Turquoise")         },
+    { RGB(0xC0, 0xFF, 0xFF),    _T("Skyblue")           },
+    { RGB(0x48, 0x00, 0x48),    _T("Plum")              },
+    { RGB(0xC0, 0xC0, 0xC0),    _T("Light grey")        },
+
+    { RGB(0xFF, 0xE4, 0xE1),    _T("Rose")              },
+    { RGB(0xD2, 0xB4, 0x8C),    _T("Tan")               },
+    { RGB(0xFF, 0xFF, 0xE0),    _T("Light yellow")      },
+    { RGB(0x98, 0xFB, 0x98),    _T("Pale green ")       },
+    { RGB(0xAF, 0xEE, 0xEE),    _T("Pale turquoise")    },
+    { RGB(0x68, 0x83, 0x8B),    _T("Pale blue")         },
+    { RGB(0xE6, 0xE6, 0xFA),    _T("Lavender")          },
+    { RGB(0xFF, 0xFF, 0xFF),    _T("White")             }
+};
+
+/////////////////////////////////////////////////////////////////////////////
+// CColourPopup
+
+CColourPopup::CColourPopup(HWND hOwner,IColorPicker *pColorPicker)
+:m_hOwner(hOwner)
+,m_pColorPicker(pColorPicker)
+{
+    Initialise();
+	MsgFilterRegister(m_hOwner);
+}
+
+void CColourPopup::Initialise()
+{
+    m_nNumColours       = sizeof(m_crColours)/sizeof(ColourTableEntry);
+    if (m_nNumColours > MAX_COLOURS)
+        m_nNumColours = MAX_COLOURS;
+
+    m_nNumColumns       = 0;
+    m_nNumRows          = 0;
+    m_nBoxSize          = 18;
+    m_nMargin           = ::GetSystemMetrics(SM_CXEDGE);
+    m_nCurrentSel       = INVALID_COLOUR;
+    m_nChosenColourSel  = INVALID_COLOUR;
+    m_crColour          = m_crInitialColour = RGB(0,0,0);
+	m_crDef				= CLR_DEFAULT;
+
+    // Idiot check: Make sure the colour square is at least 5 x 5;
+    if (m_nBoxSize - 2*m_nMargin - 2 < 5) m_nBoxSize = 5 + 2*m_nMargin + 2;
+
+    // Create the font
+    NONCLIENTMETRICS ncm;
+    ncm.cbSize = sizeof(NONCLIENTMETRICS);
+    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &ncm, 0);
+    m_Font.CreateFontIndirect(&(ncm.lfMessageFont));
+
+    // Create the palette
+    struct {
+        LOGPALETTE    LogPalette;
+        PALETTEENTRY  PalEntry[MAX_COLOURS];
+    } pal;
+
+    LOGPALETTE* pLogPalette = (LOGPALETTE*) &pal;
+    pLogPalette->palVersion    = 0x300;
+    pLogPalette->palNumEntries = (WORD) m_nNumColours; 
+
+    for (int i = 0; i < m_nNumColours; i++)
+    {
+        pLogPalette->palPalEntry[i].peRed   = GetRValue(m_crColours[i].crColour);
+        pLogPalette->palPalEntry[i].peGreen = GetGValue(m_crColours[i].crColour);
+        pLogPalette->palPalEntry[i].peBlue  = GetBValue(m_crColours[i].crColour);
+        pLogPalette->palPalEntry[i].peFlags = 0;
+    }
+
+    m_Palette.CreatePalette(pLogPalette);
+}
+
+CColourPopup::~CColourPopup()
+{
+	MsgFilterUnregister(m_hOwner);
+    m_Font.DeleteObject();
+    m_Palette.DeleteObject();
+}
+
+BOOL CColourPopup::Create(CPoint p, COLORREF crColour,
+                          LPCTSTR szDefaultText /* = NULL */,
+                          LPCTSTR szCustomText  /* = NULL */)
+{
+    m_crColour = m_crInitialColour = crColour;
+
+	if (!CSimpleWnd::Create(NULL, WS_VISIBLE|WS_POPUP, WS_EX_TOOLWINDOW,
+                        p.x, p.y, 100, 100, // size updated soon
+                        m_hOwner, NULL))
+        return FALSE;
+
+    // Store the Custom text
+    if (szCustomText != NULL) 
+        m_strCustomText = szCustomText;
+
+    // Store the Default Area text
+    if (szDefaultText != NULL) 
+        m_strDefaultText = szDefaultText;
+        
+    // Set the window size
+    SetWindowSize();
+
+    // Create the tooltips
+    CreateToolTips();
+
+    // Find which cell (if any) corresponds to the initial colour
+    FindCellFromColour(crColour);
+
+    // Capture all mouse events for the life of this window
+    SetCapture();
+
+    return TRUE;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CColourPopup message handlers
+
+// For tooltips
+BOOL CColourPopup::PreTranslateMessage(MSG* pMsg) 
+{
+    m_ToolTip.RelayEvent(pMsg);
+	return FALSE;
+}
+
+// If an arrow key is pressed, then move the selection
+void CColourPopup::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
+{
+    int row = GetRow(m_nCurrentSel),
+        col = GetColumn(m_nCurrentSel);
+
+    if (nChar == VK_DOWN) 
+    {
+        if (row == DEFAULT_BOX_VALUE) 
+            row = col = 0; 
+        else if (row == CUSTOM_BOX_VALUE)
+        {
+            if (m_strDefaultText.GetLength())
+                row = col = DEFAULT_BOX_VALUE;
+            else
+                row = col = 0;
+        }
+        else
+        {
+            row++;
+            if (GetIndex(row,col) < 0)
+            {
+                if (m_strCustomText.GetLength())
+                    row = col = CUSTOM_BOX_VALUE;
+                else if (m_strDefaultText.GetLength())
+                    row = col = DEFAULT_BOX_VALUE;
+                else
+                    row = col = 0;
+            }
+        }
+        ChangeSelection(GetIndex(row, col));
+    }
+
+    if (nChar == VK_UP) 
+    {
+        if (row == DEFAULT_BOX_VALUE)
+        {
+            if (m_strCustomText.GetLength())
+                row = col = CUSTOM_BOX_VALUE;
+            else
+           { 
+                row = GetRow(m_nNumColours-1); 
+                col = GetColumn(m_nNumColours-1); 
+            }
+        }
+        else if (row == CUSTOM_BOX_VALUE)
+        { 
+            row = GetRow(m_nNumColours-1); 
+            col = GetColumn(m_nNumColours-1); 
+        }
+        else if (row > 0) row--;
+        else /* row == 0 */
+        {
+            if (m_strDefaultText.GetLength())
+                row = col = DEFAULT_BOX_VALUE;
+            else if (m_strCustomText.GetLength())
+                row = col = CUSTOM_BOX_VALUE;
+            else
+            { 
+                row = GetRow(m_nNumColours-1); 
+                col = GetColumn(m_nNumColours-1); 
+            }
+        }
+        ChangeSelection(GetIndex(row, col));
+    }
+
+    if (nChar == VK_RIGHT) 
+    {
+        if (row == DEFAULT_BOX_VALUE) 
+            row = col = 0; 
+        else if (row == CUSTOM_BOX_VALUE)
+        {
+            if (m_strDefaultText.GetLength())
+                row = col = DEFAULT_BOX_VALUE;
+            else
+                row = col = 0;
+        }
+        else if (col < m_nNumColumns-1) 
+            col++;
+        else 
+        { 
+            col = 0; row++;
+        }
+
+        if (GetIndex(row,col) == INVALID_COLOUR)
+        {
+            if (m_strCustomText.GetLength())
+                row = col = CUSTOM_BOX_VALUE;
+            else if (m_strDefaultText.GetLength())
+                row = col = DEFAULT_BOX_VALUE;
+            else
+                row = col = 0;
+        }
+
+        ChangeSelection(GetIndex(row, col));
+    }
+
+    if (nChar == VK_LEFT) 
+    {
+        if (row == DEFAULT_BOX_VALUE)
+        {
+            if (m_strCustomText.GetLength())
+                row = col = CUSTOM_BOX_VALUE;
+            else
+           { 
+                row = GetRow(m_nNumColours-1); 
+                col = GetColumn(m_nNumColours-1); 
+            }
+        }
+        else if (row == CUSTOM_BOX_VALUE)
+        { 
+            row = GetRow(m_nNumColours-1); 
+            col = GetColumn(m_nNumColours-1); 
+        }
+        else if (col > 0) col--;
+        else /* col == 0 */
+        {
+            if (row > 0) { row--; col = m_nNumColumns-1; }
+            else 
+            {
+                if (m_strDefaultText.GetLength())
+                    row = col = DEFAULT_BOX_VALUE;
+                else if (m_strCustomText.GetLength())
+                    row = col = CUSTOM_BOX_VALUE;
+                else
+                { 
+                    row = GetRow(m_nNumColours-1); 
+                    col = GetColumn(m_nNumColours-1); 
+                }
+            }
+        }
+        ChangeSelection(GetIndex(row, col));
+    }
+
+    if (nChar == VK_ESCAPE) 
+    {
+        m_crColour = m_crInitialColour;
+        EndSelection(IDOK);
+        return;
+    }
+
+    if (nChar == VK_RETURN || nChar == VK_SPACE)
+    {
+        EndSelection(IDCANCEL);
+        return;
+    }
+
+}
+
+void CColourPopup::OnPaint(HDC hdc) 
+{
+    CPaintDC dc(m_hWnd); // device context for painting
+
+    // Draw the Default Area text
+    if (m_strDefaultText.GetLength())
+        DrawCell(&dc, DEFAULT_BOX_VALUE);
+ 
+    // Draw colour cells
+    for (int i = 0; i < m_nNumColours; i++)
+        DrawCell(&dc, i);
+    
+    // Draw custom text
+    if (m_strCustomText.GetLength())
+        DrawCell(&dc, CUSTOM_BOX_VALUE);
+
+    // Draw raised window edge (ex-window style WS_EX_WINDOWEDGE is sposed to do this,
+    // but for some reason isn't
+    CRect rect;
+    GetClientRect(rect);
+    dc.DrawEdge(rect, EDGE_RAISED, BF_RECT);
+}
+
+void CColourPopup::OnMouseMove(UINT nFlags, CPoint point) 
+{
+    int nNewSelection = INVALID_COLOUR;
+
+    // Translate points to be relative raised window edge
+    point.x -= m_nMargin;
+    point.y -= m_nMargin;
+
+    // First check we aren't in text box
+    if (m_strCustomText.GetLength() && m_CustomTextRect.PtInRect(point))
+        nNewSelection = CUSTOM_BOX_VALUE;
+    else if (m_strDefaultText.GetLength() && m_DefaultTextRect.PtInRect(point))
+        nNewSelection = DEFAULT_BOX_VALUE;
+    else
+    {
+        // Take into account text box
+        if (m_strDefaultText.GetLength()) 
+            point.y -= m_DefaultTextRect.Height();  
+
+        // Get the row and column
+        nNewSelection = GetIndex(point.y / m_nBoxSize, point.x / m_nBoxSize);
+
+        // In range? If not, default and exit
+        if (nNewSelection < 0 || nNewSelection >= m_nNumColours)
+        {
+            return;
+        }
+    }
+
+    // OK - we have the row and column of the current selection (may be CUSTOM_BOX_VALUE)
+    // Has the row/col selection changed? If yes, then redraw old and new cells.
+    if (nNewSelection != m_nCurrentSel)
+        ChangeSelection(nNewSelection);
+
+}
+
+// End selection on LButtonUp
+void CColourPopup::OnLButtonUp(UINT nFlags, CPoint point) 
+{    
+	ClientToScreen(&point);
+    if (m_WindowRect.PtInRect(point))
+        EndSelection(IDOK);
+    else
+        EndSelection(IDCANCEL);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CColourPopup implementation
+
+int CColourPopup::GetIndex(int row, int col) const
+{ 
+    if ((row == CUSTOM_BOX_VALUE || col == CUSTOM_BOX_VALUE) && m_strCustomText.GetLength())
+        return CUSTOM_BOX_VALUE;
+    else if ((row == DEFAULT_BOX_VALUE || col == DEFAULT_BOX_VALUE) && m_strDefaultText.GetLength())
+        return DEFAULT_BOX_VALUE;
+    else if (row < 0 || col < 0 || row >= m_nNumRows || col >= m_nNumColumns)
+        return INVALID_COLOUR;
+    else
+    {
+        if (row*m_nNumColumns + col >= m_nNumColours)
+            return INVALID_COLOUR;
+        else
+            return row*m_nNumColumns + col;
+    }
+}
+
+int CColourPopup::GetRow(int nIndex) const               
+{ 
+    if (nIndex == CUSTOM_BOX_VALUE && m_strCustomText.GetLength())
+        return CUSTOM_BOX_VALUE;
+    else if (nIndex == DEFAULT_BOX_VALUE && m_strDefaultText.GetLength())
+        return DEFAULT_BOX_VALUE;
+    else if (nIndex < 0 || nIndex >= m_nNumColours)
+        return INVALID_COLOUR;
+    else
+        return nIndex / m_nNumColumns; 
+}
+
+int CColourPopup::GetColumn(int nIndex) const            
+{ 
+    if (nIndex == CUSTOM_BOX_VALUE && m_strCustomText.GetLength())
+        return CUSTOM_BOX_VALUE;
+    else if (nIndex == DEFAULT_BOX_VALUE && m_strDefaultText.GetLength())
+        return DEFAULT_BOX_VALUE;
+    else if (nIndex < 0 || nIndex >= m_nNumColours)
+        return INVALID_COLOUR;
+    else
+        return nIndex % m_nNumColumns; 
+}
+
+void CColourPopup::FindCellFromColour(COLORREF crColour)
+{
+    if (crColour == m_crDef && m_strDefaultText.GetLength())
+    {
+        m_nChosenColourSel = DEFAULT_BOX_VALUE;
+        return;
+    }
+
+    for (int i = 0; i < m_nNumColours; i++)
+    {
+        if (GetColour(i) == crColour)
+        {
+            m_nChosenColourSel = i;
+            return;
+        }
+    }
+
+    if (m_strCustomText.GetLength())
+        m_nChosenColourSel = CUSTOM_BOX_VALUE;
+    else
+        m_nChosenColourSel = INVALID_COLOUR;
+}
+
+// Gets the dimensions of the colour cell given by (row,col)
+BOOL CColourPopup::GetCellRect(int nIndex, const LPRECT& rect)
+{
+    if (nIndex == CUSTOM_BOX_VALUE)
+    {
+        ::SetRect(rect, 
+                  m_CustomTextRect.left,  m_CustomTextRect.top,
+                  m_CustomTextRect.right, m_CustomTextRect.bottom);
+        return TRUE;
+    }
+    else if (nIndex == DEFAULT_BOX_VALUE)
+    {
+        ::SetRect(rect, 
+                  m_DefaultTextRect.left,  m_DefaultTextRect.top,
+                  m_DefaultTextRect.right, m_DefaultTextRect.bottom);
+        return TRUE;
+    }
+
+    if (nIndex < 0 || nIndex >= m_nNumColours)
+        return FALSE;
+
+    rect->left = GetColumn(nIndex) * m_nBoxSize + m_nMargin;
+    rect->top  = GetRow(nIndex) * m_nBoxSize + m_nMargin;
+
+    // Move everything down if we are displaying a default text area
+    if (m_strDefaultText.GetLength()) 
+        rect->top += (m_nMargin + m_DefaultTextRect.Height());
+
+    rect->right = rect->left + m_nBoxSize;
+    rect->bottom = rect->top + m_nBoxSize;
+
+    return TRUE;
+}
+
+// Works out an appropriate size and position of this window
+void CColourPopup::SetWindowSize()
+{
+    CSize TextSize;
+
+    // If we are showing a custom or default text area, get the font and text size.
+    if (m_strCustomText.GetLength() || m_strDefaultText.GetLength())
+    {
+        CClientDC dc(m_hWnd);
+        HFONT pOldFont =  dc.SelectFont(m_Font);
+
+        // Get the size of the custom text (if there IS custom text)
+        TextSize = CSize(0,0);
+        if (m_strCustomText.GetLength())
+            dc.GetTextExtent(m_strCustomText,m_strCustomText.GetLength(),&TextSize);
+
+        // Get the size of the default text (if there IS default text)
+        if (m_strDefaultText.GetLength())
+        {
+            CSize DefaultSize;
+			dc.GetTextExtent(m_strDefaultText,m_strDefaultText.GetLength(),&DefaultSize);
+            if (DefaultSize.cx > TextSize.cx) TextSize.cx = DefaultSize.cx;
+            if (DefaultSize.cy > TextSize.cy) TextSize.cy = DefaultSize.cy;
+        }
+
+        dc.SelectFont(pOldFont);
+        TextSize += CSize(2*m_nMargin,2*m_nMargin);
+
+        // Add even more space to draw the horizontal line
+        TextSize.cy += 2*m_nMargin + 2;
+    }
+
+    // Get the number of columns and rows
+    //m_nNumColumns = (int) sqrt((double)m_nNumColours);    // for a square window (yuk)
+    m_nNumColumns = 8;
+    m_nNumRows = m_nNumColours / m_nNumColumns;
+    if (m_nNumColours % m_nNumColumns) m_nNumRows++;
+
+    // Get the current window position, and set the new size
+    CRect rect;
+    GetWindowRect(rect);
+
+    m_WindowRect.SetRect(rect.left, rect.top, 
+                         rect.left + m_nNumColumns*m_nBoxSize + 2*m_nMargin,
+                         rect.top  + m_nNumRows*m_nBoxSize + 2*m_nMargin);
+
+    // if custom text, then expand window if necessary, and set text width as
+    // window width
+    if (m_strDefaultText.GetLength()) 
+    {
+        if (TextSize.cx > m_WindowRect.Width())
+            m_WindowRect.right = m_WindowRect.left + TextSize.cx;
+        TextSize.cx = m_WindowRect.Width()-2*m_nMargin;
+
+        // Work out the text area
+        m_DefaultTextRect.SetRect(m_nMargin, m_nMargin, 
+                                  m_nMargin+TextSize.cx, 2*m_nMargin+TextSize.cy);
+        m_WindowRect.bottom += m_DefaultTextRect.Height() + 2*m_nMargin;
+    }
+
+    // if custom text, then expand window if necessary, and set text width as
+    // window width
+    if (m_strCustomText.GetLength()) 
+    {
+        if (TextSize.cx > m_WindowRect.Width())
+            m_WindowRect.right = m_WindowRect.left + TextSize.cx;
+        TextSize.cx = m_WindowRect.Width()-2*m_nMargin;
+
+        // Work out the text area
+        m_CustomTextRect.SetRect(m_nMargin, m_WindowRect.Height(), 
+                                 m_nMargin+TextSize.cx, 
+                                 m_WindowRect.Height()+m_nMargin+TextSize.cy);
+        m_WindowRect.bottom += m_CustomTextRect.Height() + 2*m_nMargin;
+   }
+
+    // Need to check it'll fit on screen: Too far right?
+    CSize ScreenSize(::GetSystemMetrics(SM_CXSCREEN), ::GetSystemMetrics(SM_CYSCREEN));
+    if (m_WindowRect.right > ScreenSize.cx)
+        m_WindowRect.OffsetRect(-(m_WindowRect.right - ScreenSize.cx), 0);
+
+    // Too far left?
+    if (m_WindowRect.left < 0)
+        m_WindowRect.OffsetRect( -m_WindowRect.left, 0);
+
+    // Bottom falling out of screen?
+    if (m_WindowRect.bottom > ScreenSize.cy)
+    {
+        CRect ParentRect;
+//         m_pParent->GetWindowRect(ParentRect);
+//         m_WindowRect.OffsetRect(0, -(ParentRect.Height() + m_WindowRect.Height()));
+    }
+
+    // Set the window size and position
+    MoveWindow(m_WindowRect, TRUE);
+}
+
+void CColourPopup::CreateToolTips()
+{
+    // Create the tool tip
+    if (!m_ToolTip.Create(m_hWnd,0)) return;
+	
+    // Add a tool for each cell
+    for (int i = 0; i < m_nNumColours; i++)
+    {
+        CRect rect;
+         if (!GetCellRect(i, rect)) continue;
+         m_ToolTip.AddTool(m_hWnd, GetColourName(i), rect, 1);
+    }
+}
+
+void CColourPopup::ChangeSelection(int nIndex)
+{
+    CClientDC dc(m_hWnd);        // device context for drawing
+
+    if (nIndex > m_nNumColours)
+        nIndex = CUSTOM_BOX_VALUE; 
+
+    if ((m_nCurrentSel >= 0 && m_nCurrentSel < m_nNumColours) ||
+        m_nCurrentSel == CUSTOM_BOX_VALUE || m_nCurrentSel == DEFAULT_BOX_VALUE)
+    {
+        // Set Current selection as invalid and redraw old selection (this way
+        // the old selection will be drawn unselected)
+        int OldSel = m_nCurrentSel;
+        m_nCurrentSel = INVALID_COLOUR;
+        DrawCell(&dc, OldSel);
+    }
+
+    // Set the current selection as row/col and draw (it will be drawn selected)
+    m_nCurrentSel = nIndex;
+    DrawCell(&dc, m_nCurrentSel);
+
+    // Store the current colour
+     if (m_nCurrentSel == CUSTOM_BOX_VALUE) m_crColour=m_crInitialColour;
+	 else if(m_nCurrentSel == DEFAULT_BOX_VALUE) m_crColour=m_crDef;
+	 else m_crColour=GetColour(m_nCurrentSel);
+	 if(m_pColorPicker)
+		m_pColorPicker->OnColorChanged(m_crColour);
+}
+
+void CColourPopup::EndSelection(int nMessage)
+{
+    ReleaseCapture();
+
+    // If custom text selected, perform a custom colour selection
+    if (nMessage != IDCANCEL && m_nCurrentSel == CUSTOM_BOX_VALUE)
+    {
+		ShowWindow(SW_HIDE);
+		MyChooseColor(m_crColour);
+    }
+
+    if (nMessage == IDCANCEL)
+        m_crColour = m_crInitialColour;
+
+	if(m_pColorPicker)
+		m_pColorPicker->OnColorEnd(nMessage==IDCANCEL,m_crColour);
+
+    DestroyWindow();
+}
+
+void CColourPopup::DrawCell(CDC* pDC, int nIndex)
+{
+    // For the Custom Text area
+    if (m_strCustomText.GetLength() && nIndex == CUSTOM_BOX_VALUE)
+    {
+        // The extent of the actual text button
+        CRect TextButtonRect = m_CustomTextRect;
+        TextButtonRect.top += 2*m_nMargin;
+
+        // Fill background
+        pDC->FillSolidRect(TextButtonRect, ::GetSysColor(COLOR_3DFACE));
+
+        // Draw horizontal line
+        pDC->FillSolidRect(m_CustomTextRect.left+2*m_nMargin, m_CustomTextRect.top,
+                           m_CustomTextRect.Width()-4*m_nMargin, 1, ::GetSysColor(COLOR_3DSHADOW));
+        pDC->FillSolidRect(m_CustomTextRect.left+2*m_nMargin, m_CustomTextRect.top+1,
+                           m_CustomTextRect.Width()-4*m_nMargin, 1, ::GetSysColor(COLOR_3DHILIGHT));
+
+        TextButtonRect.DeflateRect(1,1);
+
+        // fill background
+        if (m_nChosenColourSel == nIndex && m_nCurrentSel != nIndex)
+            pDC->FillSolidRect(TextButtonRect, ::GetSysColor(COLOR_3DLIGHT));
+        else
+            pDC->FillSolidRect(TextButtonRect, ::GetSysColor(COLOR_3DFACE));
+
+        // Draw button
+        if (m_nCurrentSel == nIndex) 
+            pDC->DrawEdge(TextButtonRect, BDR_RAISEDINNER, BF_RECT);
+        else if (m_nChosenColourSel == nIndex)
+            pDC->DrawEdge(TextButtonRect, BDR_SUNKENOUTER, BF_RECT);
+
+        // Draw custom text
+        HFONT pOldFont= pDC->SelectFont(m_Font);
+        pDC->SetBkMode(TRANSPARENT);
+        pDC->DrawText(m_strCustomText,m_strCustomText.GetLength(), TextButtonRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
+        pDC->SelectFont(pOldFont);
+
+        return;
+    }        
+
+    // For the Default Text area
+    if (m_strDefaultText.GetLength() && nIndex == DEFAULT_BOX_VALUE)
+    {
+        // Fill background
+        pDC->FillSolidRect(m_DefaultTextRect, ::GetSysColor(COLOR_3DFACE));
+
+        // The extent of the actual text button
+        CRect TextButtonRect = m_DefaultTextRect;
+        TextButtonRect.DeflateRect(1,1);
+
+        // fill background
+        if (m_nChosenColourSel == nIndex && m_nCurrentSel != nIndex)
+            pDC->FillSolidRect(TextButtonRect, ::GetSysColor(COLOR_3DLIGHT));
+        else
+            pDC->FillSolidRect(TextButtonRect, ::GetSysColor(COLOR_3DFACE));
+
+        // Draw thin line around text
+        CRect LineRect = TextButtonRect;
+        LineRect.DeflateRect(2*m_nMargin,2*m_nMargin);
+        CPen pen;
+		pen.CreatePen(PS_SOLID, 1, ::GetSysColor(COLOR_3DSHADOW));
+        HPEN pOldPen = pDC->SelectPen(pen);
+        pDC->SelectBrush((HBRUSH)GetStockObject(NULL_BRUSH));
+        pDC->Rectangle(LineRect);
+        pDC->SelectPen(pOldPen);
+
+        // Draw button
+        if (m_nCurrentSel == nIndex) 
+            pDC->DrawEdge(TextButtonRect, BDR_RAISEDINNER, BF_RECT);
+        else if (m_nChosenColourSel == nIndex)
+            pDC->DrawEdge(TextButtonRect, BDR_SUNKENOUTER, BF_RECT);
+
+        // Draw custom text
+        HFONT pOldFont = pDC->SelectFont(m_Font);
+        pDC->SetBkMode(TRANSPARENT);
+        pDC->DrawText(m_strDefaultText,m_strDefaultText.GetLength(), TextButtonRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
+        pDC->SelectFont(pOldFont);
+
+        return;
+    }        
+
+    CRect rect;
+    if (!GetCellRect(nIndex, rect)) return;
+
+    // fill background
+    if (m_nChosenColourSel == nIndex && m_nCurrentSel != nIndex)
+        pDC->FillSolidRect(rect, ::GetSysColor(COLOR_3DHILIGHT));
+    else
+        pDC->FillSolidRect(rect, ::GetSysColor(COLOR_3DFACE));
+
+    // Draw button
+    if (m_nCurrentSel == nIndex) 
+        pDC->DrawEdge(rect, BDR_RAISEDINNER, BF_RECT);
+    else if (m_nChosenColourSel == nIndex)
+        pDC->DrawEdge(rect, BDR_SUNKENOUTER, BF_RECT);
+
+    CBrush brush(RGB(GetRValue(GetColour(nIndex)), 
+                            GetGValue(GetColour(nIndex)), 
+                            GetBValue(GetColour(nIndex)) ));
+    CPen   pen;
+    pen.CreatePen(PS_SOLID, 1, ::GetSysColor(COLOR_3DSHADOW));
+
+    HBRUSH pOldBrush =  pDC->SelectBrush(brush);
+    HPEN   pOldPen   =    pDC->SelectPen(pen);
+
+    // Draw the cell colour
+    rect.DeflateRect(m_nMargin+1, m_nMargin+1);
+    pDC->Rectangle(rect);
+
+    // restore DC and cleanup
+    pDC->SelectBrush(pOldBrush);
+    pDC->SelectPen(pOldPen);
+    brush.DeleteObject();
+    pen.DeleteObject();
+
+}
+
+void CColourPopup::OnKillFocus(HWND hNewWnd) 
+{
+    ReleaseCapture();
+}
+
+
+// KillFocus problem fix suggested by Paul Wilkerson.
+void CColourPopup::OnActivateApp(BOOL bActive, DWORD hTask) 
+{
+	DefWindowProc();
+	// If Deactivating App, cancel this selection
+	if (!bActive)	EndSelection(IDCANCEL);
+}
+
+void CColourPopup::OnFinalMessage( HWND hWnd )
+{
+	delete this;
+}
+
+BOOL CColourPopup::MyChooseColor(COLORREF &cr)
+{
+	CHOOSECOLOR cc;                 // common dialog box structure 
+	static COLORREF acrCustClr[16]; // array of custom colors 
+
+	// Initialize CHOOSECOLOR 
+	ZeroMemory(&cc, sizeof(cc));
+	cc.lStructSize = sizeof(cc);
+	cc.hwndOwner = m_hWnd;
+	cc.lpCustColors = (LPDWORD) acrCustClr;
+	cc.rgbResult = cr;
+	cc.Flags = CC_FULLOPEN | CC_RGBINIT;
+
+	if (!ChooseColor(&cc)) return FALSE;
+
+	cr=cc.rgbResult;
+	return TRUE;
+}
+
+}//end of namespace
Index: colorpicker/ColourPopup.h
===================================================================
--- colorpicker/ColourPopup.h	(revision 0)
+++ colorpicker/ColourPopup.h	(working copy)
@@ -0,0 +1,121 @@
+#ifndef COLOURPOPUP_INCLUDED
+#define COLOURPOPUP_INCLUDED
+#pragma once 
+
+
+// ColourPopup.h : header file
+//
+// Written by Chris Maunder (chrismaunder@codeguru.com)
+// Extended by Alexander Bischofberger (bischofb@informatik.tu-muenchen.de)
+// Copyright (c) 1998.
+//
+// This code may be used in compiled form in any way you desire. This
+// file may be redistributed unmodified by any means PROVIDING it is 
+// not sold for profit without the authors written consent, and 
+// providing that this notice and the authors name is included. If 
+// the source code in  this file is used in any commercial application 
+// then a simple email would be nice.
+//
+// This file is provided "as is" with no expressed or implied warranty.
+// The author accepts no liability if it causes any damage whatsoever.
+// It's free - so you get what you pay for.
+
+#include "tooltipctrl.h"
+
+namespace DuiEngine
+{
+
+struct IColorPicker{
+	virtual void OnColorChanged(COLORREF cr)=0;
+	virtual void OnColorEnd(BOOL bCancel,COLORREF cr)=0;
+};
+
+/////////////////////////////////////////////////////////////////////////////
+// CColourPopup window
+
+class CColourPopup : public CSimpleWnd , public CDuiMessageFilter
+{
+	// To hold the colours and their names
+	typedef struct {
+		COLORREF crColour;
+		TCHAR    *szName;
+	} ColourTableEntry;
+// Construction
+public:
+    CColourPopup(HWND hOwner,IColorPicker *pColorPicker);
+
+	virtual ~CColourPopup();
+
+// Operations
+public:
+    BOOL Create(CPoint p, COLORREF crColour, LPCTSTR szDefaultText = NULL, LPCTSTR szCustomText = NULL);
+
+	void SetDefColor(COLORREF crDef){m_crDef=crDef;}
+public:
+    virtual BOOL PreTranslateMessage(MSG* pMsg);
+
+protected:
+	void Initialise();
+    BOOL GetCellRect(int nIndex, const LPRECT& rect);
+    void FindCellFromColour(COLORREF crColour);
+    void SetWindowSize();
+    void CreateToolTips();
+    void ChangeSelection(int nIndex);
+    void EndSelection(int nMessage);
+    void DrawCell(CDC* pDC, int nIndex);
+
+    COLORREF GetColour(int nIndex)              { return m_crColours[nIndex].crColour; }
+    LPCTSTR GetColourName(int nIndex)           { return m_crColours[nIndex].szName; }
+    int  GetIndex(int row, int col) const;
+    int  GetRow(int nIndex) const;
+    int  GetColumn(int nIndex) const;
+
+	BOOL MyChooseColor(COLORREF &cr);
+
+// protected attributes
+protected:
+    static ColourTableEntry m_crColours[];
+    int            m_nNumColours;
+    int            m_nNumColumns, m_nNumRows;
+    int            m_nBoxSize, m_nMargin;
+    int            m_nCurrentSel;
+    int            m_nChosenColourSel;
+    CDuiStringT        m_strDefaultText;
+    CDuiStringT        m_strCustomText;
+    CRect          m_CustomTextRect, m_DefaultTextRect, m_WindowRect;
+    CFont          m_Font;
+    CPalette       m_Palette;
+    COLORREF       m_crInitialColour, m_crColour;
+	COLORREF		m_crDef;
+    CSimpleToolTip   m_ToolTip;
+
+	HWND			m_hOwner;
+	IColorPicker	*m_pColorPicker;
+    // Generated message map functions
+protected:
+    void OnLButtonUp(UINT nFlags, CPoint point);
+    void OnPaint(HDC hdc);
+    void OnMouseMove(UINT nFlags, CPoint point);
+    void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
+	void OnKillFocus(HWND hNewWnd);
+	void OnActivateApp(BOOL bActive, DWORD hTask);
+
+	virtual void OnFinalMessage(HWND hWnd);
+
+	BEGIN_MSG_MAP_EX(CColourPopup)
+		MSG_WM_LBUTTONUP(OnLButtonUp)
+		MSG_WM_PAINT(OnPaint)
+		MSG_WM_MOUSEMOVE(OnMouseMove)
+		MSG_WM_KEYDOWN(OnKeyDown)
+		MSG_WM_KILLFOCUS(OnKillFocus)
+		MSG_WM_ACTIVATEAPP(OnActivateApp)
+	END_MSG_MAP()
+};
+
+
+}//end of namespace
+
+/////////////////////////////////////////////////////////////////////////////
+
+
+#endif // !defined(AFX_COLOURPOPUP_H__D0B75902_9830_11D1_9C0F_00A0243D1382__INCLUDED_)
Index: colorpicker/DuiColorPicker.cpp
===================================================================
--- colorpicker/DuiColorPicker.cpp	(revision 0)
+++ colorpicker/DuiColorPicker.cpp	(working copy)
@@ -0,0 +1,60 @@
+#include "StdAfx.h"
+#include "DuiColorPicker.h"
+
+namespace DuiEngine
+{
+
+CDuiColorPicker::CDuiColorPicker(void):m_crDef(0),m_crCur(0)
+{
+}
+
+CDuiColorPicker::~CDuiColorPicker(void)
+{
+}
+
+void CDuiColorPicker::OnPaint( CDCHandle dc )
+{
+	CRect rcClient;
+	GetClient(&rcClient);
+	ALPHAINFO ai;
+	CGdiAlpha::AlphaBackup(dc,rcClient,ai);
+	dc.FillSolidRect(&rcClient,m_crCur);
+	dc.DrawEdge(&rcClient, BDR_RAISEDINNER, BF_RECT);
+	CGdiAlpha::AlphaRestore(dc,ai);
+}
+
+void CDuiColorPicker::OnLButtonUp( UINT nFlags,CPoint pt )
+{
+	__super::OnLButtonUp(nFlags,pt);
+	CColourPopup *pCrPopup = new CColourPopup(GetContainer()->GetHostHwnd(),this);
+	CRect rcWnd;
+	GetRect(rcWnd);
+	pt.x=rcWnd.left,pt.y=rcWnd.bottom;
+	::ClientToScreen(GetContainer()->GetHostHwnd(),&pt);
+	pCrPopup->SetDefColor(m_crDef);
+	pCrPopup->Create(pt,m_crCur,_T("Ä¬ÈÏ"),_T("¸ü¶à"));
+}
+
+void CDuiColorPicker::OnColorChanged( COLORREF cr )
+{
+	m_crCur=cr;
+	NotifyInvalidate();
+
+}
+
+void CDuiColorPicker::OnColorEnd( BOOL bCancel,COLORREF cr )
+{
+	if(bCancel) m_crCur=m_crDef;
+	else m_crCur=cr;
+	ModifyState(0,DuiWndState_PushDown,TRUE);
+	DUINMCOLORCHANGE nm;
+	nm.hdr.code=DUINM_COLORCHANGE;
+	nm.hdr.hDuiWnd=m_hDuiWnd;
+	nm.hdr.idFrom=m_uCmdID;
+	nm.hdr.pszNameFrom=GetName();
+	nm.crSel=m_crCur;
+
+	DuiNotify((LPDUINMHDR)&nm);
+}
+
+}//end of namespace
\ No newline at end of file
Index: colorpicker/DuiColorPicker.h
===================================================================
--- colorpicker/DuiColorPicker.h	(revision 0)
+++ colorpicker/DuiColorPicker.h	(working copy)
@@ -0,0 +1,44 @@
+#pragma once
+#include "ColourPopup.h"
+
+namespace DuiEngine
+{
+#define DUINM_COLORCHANGE	100
+
+	typedef struct tagDUINMCOLORCHANGE
+	{
+		DUINMHDR hdr;
+		COLORREF crSel;
+	}DUINMCOLORCHANGE,*LPDUINMCOLORCHANGE;
+
+class CDuiColorPicker :
+	public CDuiButton ,
+	public IColorPicker
+{
+	DUIOBJ_DECLARE_CLASS_NAME(CDuiColorPicker, "colorpicker")
+
+public:
+	CDuiColorPicker(void);
+	~CDuiColorPicker(void);
+
+protected://IColorPicker
+	virtual void OnColorChanged(COLORREF cr);
+	virtual void OnColorEnd(BOOL bCancel,COLORREF cr);
+protected:
+	void OnPaint(CDCHandle dc);
+	void OnLButtonUp(UINT nFlags,CPoint pt);
+
+	DUIWIN_BEGIN_MSG_MAP()
+		MSG_WM_PAINT(OnPaint)
+		MSG_WM_LBUTTONUP(OnLButtonUp)
+	DUIWIN_END_MSG_MAP()
+
+	DUIWIN_DECLARE_ATTRIBUTES_BEGIN()
+		DUIWIN_COLOR_ATTRIBUTE("color",m_crCur=m_crDef,TRUE)
+	DUIWIN_DECLARE_ATTRIBUTES_END()
+	
+	COLORREF	m_crDef;
+	COLORREF	m_crCur;
+};
+
+}
Index: colorpicker/Tooltipctrl.h
===================================================================
--- colorpicker/Tooltipctrl.h	(revision 0)
+++ colorpicker/Tooltipctrl.h	(working copy)
@@ -0,0 +1,76 @@
+#pragma once
+
+#include <SimpleWnd.h>
+
+namespace DuiEngine{
+
+typedef struct tagAFX_OLDTOOLINFO1 {
+	UINT cbSize;
+	UINT uFlags;
+	HWND hwnd;
+	UINT uId;
+	RECT rect;
+	HINSTANCE hinst;
+	LPTSTR lpszText;
+} AFX_OLDTOOLINFO1;
+
+class CSimpleToolTip : public CSimpleWnd
+{
+public:
+	BOOL Create(HWND hParent,DWORD dwExStyle,HINSTANCE hInst=NULL)
+	{
+		HWND hWnd=::CreateWindowEx(dwExStyle,TOOLTIPS_CLASS,NULL,WS_POPUP,0,0,0,0,hParent,0,hInst,0);
+		if(!hWnd) return FALSE;
+		return SubclassWindow(hWnd);
+	}
+
+	BOOL AddTool(HWND hWnd, LPCTSTR lpszText, LPCRECT lpRectTool,
+		UINT_PTR nIDTool)
+	{
+		DUIASSERT(::IsWindow(m_hWnd));
+		DUIASSERT(::IsWindow(hWnd));
+		DUIASSERT(lpszText != NULL);
+		// the toolrect and toolid must both be zero or both valid
+		DUIASSERT((lpRectTool != NULL && nIDTool != 0) ||
+			(lpRectTool == NULL) && (nIDTool == 0));
+
+		TOOLINFO ti;
+		FillInToolInfo(ti, hWnd, nIDTool);
+		if (lpRectTool != NULL)
+		{
+			ti.rect=*lpRectTool;
+		}
+
+		ti.lpszText = (LPTSTR)lpszText;
+		return (BOOL) ::SendMessage(m_hWnd, TTM_ADDTOOL, 0, (LPARAM)&ti);
+	}
+
+	void RelayEvent(LPMSG lpMsg)
+	{ 
+		DUIASSERT(::IsWindow(m_hWnd)); 
+		::SendMessage(m_hWnd, TTM_RELAYEVENT, 0, (LPARAM)lpMsg); 
+	}
+
+protected:
+	void FillInToolInfo(TOOLINFO& ti, HWND hwnd, UINT_PTR nIDTool) const
+	{
+		memset(&ti, 0, sizeof(TOOLINFO));
+		ti.cbSize = sizeof(AFX_OLDTOOLINFO1);
+		if (nIDTool == 0)
+		{
+			ti.hwnd = ::GetParent(hwnd);
+			ti.uFlags = TTF_IDISHWND;
+			ti.uId = (UINT_PTR)hwnd;
+		}
+		else
+		{
+			ti.hwnd = hwnd;
+			ti.uFlags = 0;
+			ti.uId = nIDTool;
+		}
+	}
+
+};
+
+
+}//end of namespace
Index: colorpicker/ColourPopup.cpp
===================================================================
--- colorpicker/ColourPopup.cpp	(revision 0)
+++ colorpicker/ColourPopup.cpp	(working copy)
@@ -0,0 +1,844 @@
+// ColourPopup.cpp : implementation file
+//
+// Written by Chris Maunder (chrismaunder@codeguru.com)
+// Extended by Alexander Bischofberger (bischofb@informatik.tu-muenchen.de)
+// Copyright (c) 1998.
+//
+// Updated 30 May 1998 to allow any number of colours, and to
+//                     make the appearance closer to Office 97. 
+//                     Also added "Default" text area.         (CJM)
+//
+//         13 June 1998 Fixed change of focus bug (CJM)
+//         30 June 1998 Fixed bug caused by focus bug fix (D'oh!!)
+//                      Solution suggested by Paul Wilkerson.
+//
+// ColourPopup is a helper class for the colour picker control
+// CColourPicker. Check out the header file or the accompanying 
+// HTML doc file for details.
+//
+// This code may be used in compiled form in any way you desire. This
+// file may be redistributed unmodified by any means PROVIDING it is 
+// not sold for profit without the authors written consent, and 
+// providing that this notice and the authors name is included. 
+//
+// This file is provided "as is" with no expressed or implied warranty.
+// The author accepts no liability if it causes any damage to you or your
+// computer whatsoever. It's free, so don't hassle me about it.
+//
+// Expect bugs.
+// 
+// Please use and enjoy. Please let me know of any bugs/mods/improvements 
+// that you have found/implemented and I will fix/incorporate them into this
+// file. 
+
+#include "stdafx.h"
+#include <math.h>
+#include "ColourPopup.h"
+
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
+#endif
+
+#define DEFAULT_BOX_VALUE -3
+#define CUSTOM_BOX_VALUE  -2
+#define INVALID_COLOUR    -1
+
+#define MAX_COLOURS      100
+
+
+namespace DuiEngine
+{
+
+CColourPopup::ColourTableEntry CColourPopup::m_crColours[] = 
+{
+    { RGB(0x00, 0x00, 0x00),    _T("Black")             },
+    { RGB(0xA5, 0x2A, 0x00),    _T("Brown")             },
+    { RGB(0x00, 0x40, 0x40),    _T("Dark Olive Green")  },
+    { RGB(0x00, 0x55, 0x00),    _T("Dark Green")        },
+    { RGB(0x00, 0x00, 0x5E),    _T("Dark Teal")         },
+    { RGB(0x00, 0x00, 0x8B),    _T("Dark blue")         },
+    { RGB(0x4B, 0x00, 0x82),    _T("Indigo")            },
+    { RGB(0x28, 0x28, 0x28),    _T("Dark grey")         },
+
+    { RGB(0x8B, 0x00, 0x00),    _T("Dark red")          },
+    { RGB(0xFF, 0x68, 0x20),    _T("Orange")            },
+    { RGB(0x8B, 0x8B, 0x00),    _T("Dark yellow")       },
+    { RGB(0x00, 0x93, 0x00),    _T("Green")             },
+    { RGB(0x38, 0x8E, 0x8E),    _T("Teal")              },
+    { RGB(0x00, 0x00, 0xFF),    _T("Blue")              },
+    { RGB(0x7B, 0x7B, 0xC0),    _T("Blue-grey")         },
+    { RGB(0x66, 0x66, 0x66),    _T("Grey - 40")         },
+
+    { RGB(0xFF, 0x00, 0x00),    _T("Red")               },
+    { RGB(0xFF, 0xAD, 0x5B),    _T("Light orange")      },
+    { RGB(0x32, 0xCD, 0x32),    _T("Lime")              }, 
+    { RGB(0x3C, 0xB3, 0x71),    _T("Sea green")         },
+    { RGB(0x7F, 0xFF, 0xD4),    _T("Aqua")              },
+    { RGB(0x7D, 0x9E, 0xC0),    _T("Light blue")        },
+    { RGB(0x80, 0x00, 0x80),    _T("Violet")            },
+    { RGB(0x7F, 0x7F, 0x7F),    _T("Grey - 50")         },
+
+    { RGB(0xFF, 0xC0, 0xCB),    _T("Pink")              },
+    { RGB(0xFF, 0xD7, 0x00),    _T("Gold")              },
+    { RGB(0xFF, 0xFF, 0x00),    _T("Yellow")            },    
+    { RGB(0x00, 0xFF, 0x00),    _T("Bright green")      },
+    { RGB(0x40, 0xE0, 0xD0),    _T("Turquoise")         },
+    { RGB(0xC0, 0xFF, 0xFF),    _T("Skyblue")           },
+    { RGB(0x48, 0x00, 0x48),    _T("Plum")              },
+    { RGB(0xC0, 0xC0, 0xC0),    _T("Light grey")        },
+
+    { RGB(0xFF, 0xE4, 0xE1),    _T("Rose")              },
+    { RGB(0xD2, 0xB4, 0x8C),    _T("Tan")               },
+    { RGB(0xFF, 0xFF, 0xE0),    _T("Light yellow")      },
+    { RGB(0x98, 0xFB, 0x98),    _T("Pale green ")       },
+    { RGB(0xAF, 0xEE, 0xEE),    _T("Pale turquoise")    },
+    { RGB(0x68, 0x83, 0x8B),    _T("Pale blue")         },
+    { RGB(0xE6, 0xE6, 0xFA),    _T("Lavender")          },
+    { RGB(0xFF, 0xFF, 0xFF),    _T("White")             }
+};
+
+/////////////////////////////////////////////////////////////////////////////
+// CColourPopup
+
+CColourPopup::CColourPopup(HWND hOwner,IColorPicker *pColorPicker)
+:m_hOwner(hOwner)
+,m_pColorPicker(pColorPicker)
+{
+    Initialise();
+	MsgFilterRegister(m_hOwner);
+}
+
+void CColourPopup::Initialise()
+{
+    m_nNumColours       = sizeof(m_crColours)/sizeof(ColourTableEntry);
+    if (m_nNumColours > MAX_COLOURS)
+        m_nNumColours = MAX_COLOURS;
+
+    m_nNumColumns       = 0;
+    m_nNumRows          = 0;
+    m_nBoxSize          = 18;
+    m_nMargin           = ::GetSystemMetrics(SM_CXEDGE);
+    m_nCurrentSel       = INVALID_COLOUR;
+    m_nChosenColourSel  = INVALID_COLOUR;
+    m_crColour          = m_crInitialColour = RGB(0,0,0);
+	m_crDef				= CLR_DEFAULT;
+
+    // Idiot check: Make sure the colour square is at least 5 x 5;
+    if (m_nBoxSize - 2*m_nMargin - 2 < 5) m_nBoxSize = 5 + 2*m_nMargin + 2;
+
+    // Create the font
+    NONCLIENTMETRICS ncm;
+    ncm.cbSize = sizeof(NONCLIENTMETRICS);
+    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &ncm, 0);
+    m_Font.CreateFontIndirect(&(ncm.lfMessageFont));
+
+    // Create the palette
+    struct {
+        LOGPALETTE    LogPalette;
+        PALETTEENTRY  PalEntry[MAX_COLOURS];
+    } pal;
+
+    LOGPALETTE* pLogPalette = (LOGPALETTE*) &pal;
+    pLogPalette->palVersion    = 0x300;
+    pLogPalette->palNumEntries = (WORD) m_nNumColours; 
+
+    for (int i = 0; i < m_nNumColours; i++)
+    {
+        pLogPalette->palPalEntry[i].peRed   = GetRValue(m_crColours[i].crColour);
+        pLogPalette->palPalEntry[i].peGreen = GetGValue(m_crColours[i].crColour);
+        pLogPalette->palPalEntry[i].peBlue  = GetBValue(m_crColours[i].crColour);
+        pLogPalette->palPalEntry[i].peFlags = 0;
+    }
+
+    m_Palette.CreatePalette(pLogPalette);
+}
+
+CColourPopup::~CColourPopup()
+{
+	MsgFilterUnregister(m_hOwner);
+    m_Font.DeleteObject();
+    m_Palette.DeleteObject();
+}
+
+BOOL CColourPopup::Create(CPoint p, COLORREF crColour,
+                          LPCTSTR szDefaultText /* = NULL */,
+                          LPCTSTR szCustomText  /* = NULL */)
+{
+    m_crColour = m_crInitialColour = crColour;
+
+	if (!CSimpleWnd::Create(NULL, WS_VISIBLE|WS_POPUP, WS_EX_TOOLWINDOW,
+                        p.x, p.y, 100, 100, // size updated soon
+                        m_hOwner, NULL))
+        return FALSE;
+
+    // Store the Custom text
+    if (szCustomText != NULL) 
+        m_strCustomText = szCustomText;
+
+    // Store the Default Area text
+    if (szDefaultText != NULL) 
+        m_strDefaultText = szDefaultText;
+        
+    // Set the window size
+    SetWindowSize();
+
+    // Create the tooltips
+    CreateToolTips();
+
+    // Find which cell (if any) corresponds to the initial colour
+    FindCellFromColour(crColour);
+
+    // Capture all mouse events for the life of this window
+    SetCapture();
+
+    return TRUE;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CColourPopup message handlers
+
+// For tooltips
+BOOL CColourPopup::PreTranslateMessage(MSG* pMsg) 
+{
+    m_ToolTip.RelayEvent(pMsg);
+	return FALSE;
+}
+
+// If an arrow key is pressed, then move the selection
+void CColourPopup::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
+{
+    int row = GetRow(m_nCurrentSel),
+        col = GetColumn(m_nCurrentSel);
+
+    if (nChar == VK_DOWN) 
+    {
+        if (row == DEFAULT_BOX_VALUE) 
+            row = col = 0; 
+        else if (row == CUSTOM_BOX_VALUE)
+        {
+            if (m_strDefaultText.GetLength())
+                row = col = DEFAULT_BOX_VALUE;
+            else
+                row = col = 0;
+        }
+        else
+        {
+            row++;
+            if (GetIndex(row,col) < 0)
+            {
+                if (m_strCustomText.GetLength())
+                    row = col = CUSTOM_BOX_VALUE;
+                else if (m_strDefaultText.GetLength())
+                    row = col = DEFAULT_BOX_VALUE;
+                else
+                    row = col = 0;
+            }
+        }
+        ChangeSelection(GetIndex(row, col));
+    }
+
+    if (nChar == VK_UP) 
+    {
+        if (row == DEFAULT_BOX_VALUE)
+        {
+            if (m_strCustomText.GetLength())
+                row = col = CUSTOM_BOX_VALUE;
+            else
+           { 
+                row = GetRow(m_nNumColours-1); 
+                col = GetColumn(m_nNumColours-1); 
+            }
+        }
+        else if (row == CUSTOM_BOX_VALUE)
+        { 
+            row = GetRow(m_nNumColours-1); 
+            col = GetColumn(m_nNumColours-1); 
+        }
+        else if (row > 0) row--;
+        else /* row == 0 */
+        {
+            if (m_strDefaultText.GetLength())
+                row = col = DEFAULT_BOX_VALUE;
+            else if (m_strCustomText.GetLength())
+                row = col = CUSTOM_BOX_VALUE;
+            else
+            { 
+                row = GetRow(m_nNumColours-1); 
+                col = GetColumn(m_nNumColours-1); 
+            }
+        }
+        ChangeSelection(GetIndex(row, col));
+    }
+
+    if (nChar == VK_RIGHT) 
+    {
+        if (row == DEFAULT_BOX_VALUE) 
+            row = col = 0; 
+        else if (row == CUSTOM_BOX_VALUE)
+        {
+            if (m_strDefaultText.GetLength())
+                row = col = DEFAULT_BOX_VALUE;
+            else
+                row = col = 0;
+        }
+        else if (col < m_nNumColumns-1) 
+            col++;
+        else 
+        { 
+            col = 0; row++;
+        }
+
+        if (GetIndex(row,col) == INVALID_COLOUR)
+        {
+            if (m_strCustomText.GetLength())
+                row = col = CUSTOM_BOX_VALUE;
+            else if (m_strDefaultText.GetLength())
+                row = col = DEFAULT_BOX_VALUE;
+            else
+                row = col = 0;
+        }
+
+        ChangeSelection(GetIndex(row, col));
+    }
+
+    if (nChar == VK_LEFT) 
+    {
+        if (row == DEFAULT_BOX_VALUE)
+        {
+            if (m_strCustomText.GetLength())
+                row = col = CUSTOM_BOX_VALUE;
+            else
+           { 
+                row = GetRow(m_nNumColours-1); 
+                col = GetColumn(m_nNumColours-1); 
+            }
+        }
+        else if (row == CUSTOM_BOX_VALUE)
+        { 
+            row = GetRow(m_nNumColours-1); 
+            col = GetColumn(m_nNumColours-1); 
+        }
+        else if (col > 0) col--;
+        else /* col == 0 */
+        {
+            if (row > 0) { row--; col = m_nNumColumns-1; }
+            else 
+            {
+                if (m_strDefaultText.GetLength())
+                    row = col = DEFAULT_BOX_VALUE;
+                else if (m_strCustomText.GetLength())
+                    row = col = CUSTOM_BOX_VALUE;
+                else
+                { 
+                    row = GetRow(m_nNumColours-1); 
+                    col = GetColumn(m_nNumColours-1); 
+                }
+            }
+        }
+        ChangeSelection(GetIndex(row, col));
+    }
+
+    if (nChar == VK_ESCAPE) 
+    {
+        m_crColour = m_crInitialColour;
+        EndSelection(IDOK);
+        return;
+    }
+
+    if (nChar == VK_RETURN || nChar == VK_SPACE)
+    {
+        EndSelection(IDCANCEL);
+        return;
+    }
+
+}
+
+void CColourPopup::OnPaint(HDC hdc) 
+{
+    CPaintDC dc(m_hWnd); // device context for painting
+
+    // Draw the Default Area text
+    if (m_strDefaultText.GetLength())
+        DrawCell(&dc, DEFAULT_BOX_VALUE);
+ 
+    // Draw colour cells
+    for (int i = 0; i < m_nNumColours; i++)
+        DrawCell(&dc, i);
+    
+    // Draw custom text
+    if (m_strCustomText.GetLength())
+        DrawCell(&dc, CUSTOM_BOX_VALUE);
+
+    // Draw raised window edge (ex-window style WS_EX_WINDOWEDGE is sposed to do this,
+    // but for some reason isn't
+    CRect rect;
+    GetClientRect(rect);
+    dc.DrawEdge(rect, EDGE_RAISED, BF_RECT);
+}
+
+void CColourPopup::OnMouseMove(UINT nFlags, CPoint point) 
+{
+    int nNewSelection = INVALID_COLOUR;
+
+    // Translate points to be relative raised window edge
+    point.x -= m_nMargin;
+    point.y -= m_nMargin;
+
+    // First check we aren't in text box
+    if (m_strCustomText.GetLength() && m_CustomTextRect.PtInRect(point))
+        nNewSelection = CUSTOM_BOX_VALUE;
+    else if (m_strDefaultText.GetLength() && m_DefaultTextRect.PtInRect(point))
+        nNewSelection = DEFAULT_BOX_VALUE;
+    else
+    {
+        // Take into account text box
+        if (m_strDefaultText.GetLength()) 
+            point.y -= m_DefaultTextRect.Height();  
+
+        // Get the row and column
+        nNewSelection = GetIndex(point.y / m_nBoxSize, point.x / m_nBoxSize);
+
+        // In range? If not, default and exit
+        if (nNewSelection < 0 || nNewSelection >= m_nNumColours)
+        {
+            return;
+        }
+    }
+
+    // OK - we have the row and column of the current selection (may be CUSTOM_BOX_VALUE)
+    // Has the row/col selection changed? If yes, then redraw old and new cells.
+    if (nNewSelection != m_nCurrentSel)
+        ChangeSelection(nNewSelection);
+
+}
+
+// End selection on LButtonUp
+void CColourPopup::OnLButtonUp(UINT nFlags, CPoint point) 
+{    
+	ClientToScreen(&point);
+    if (m_WindowRect.PtInRect(point))
+        EndSelection(IDOK);
+    else
+        EndSelection(IDCANCEL);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CColourPopup implementation
+
+int CColourPopup::GetIndex(int row, int col) const
+{ 
+    if ((row == CUSTOM_BOX_VALUE || col == CUSTOM_BOX_VALUE) && m_strCustomText.GetLength())
+        return CUSTOM_BOX_VALUE;
+    else if ((row == DEFAULT_BOX_VALUE || col == DEFAULT_BOX_VALUE) && m_strDefaultText.GetLength())
+        return DEFAULT_BOX_VALUE;
+    else if (row < 0 || col < 0 || row >= m_nNumRows || col >= m_nNumColumns)
+        return INVALID_COLOUR;
+    else
+    {
+        if (row*m_nNumColumns + col >= m_nNumColours)
+            return INVALID_COLOUR;
+        else
+            return row*m_nNumColumns + col;
+    }
+}
+
+int CColourPopup::GetRow(int nIndex) const               
+{ 
+    if (nIndex == CUSTOM_BOX_VALUE && m_strCustomText.GetLength())
+        return CUSTOM_BOX_VALUE;
+    else if (nIndex == DEFAULT_BOX_VALUE && m_strDefaultText.GetLength())
+        return DEFAULT_BOX_VALUE;
+    else if (nIndex < 0 || nIndex >= m_nNumColours)
+        return INVALID_COLOUR;
+    else
+        return nIndex / m_nNumColumns; 
+}
+
+int CColourPopup::GetColumn(int nIndex) const            
+{ 
+    if (nIndex == CUSTOM_BOX_VALUE && m_strCustomText.GetLength())
+        return CUSTOM_BOX_VALUE;
+    else if (nIndex == DEFAULT_BOX_VALUE && m_strDefaultText.GetLength())
+        return DEFAULT_BOX_VALUE;
+    else if (nIndex < 0 || nIndex >= m_nNumColours)
+        return INVALID_COLOUR;
+    else
+        return nIndex % m_nNumColumns; 
+}
+
+void CColourPopup::FindCellFromColour(COLORREF crColour)
+{
+    if (crColour == m_crDef && m_strDefaultText.GetLength())
+    {
+        m_nChosenColourSel = DEFAULT_BOX_VALUE;
+        return;
+    }
+
+    for (int i = 0; i < m_nNumColours; i++)
+    {
+        if (GetColour(i) == crColour)
+        {
+            m_nChosenColourSel = i;
+            return;
+        }
+    }
+
+    if (m_strCustomText.GetLength())
+        m_nChosenColourSel = CUSTOM_BOX_VALUE;
+    else
+        m_nChosenColourSel = INVALID_COLOUR;
+}
+
+// Gets the dimensions of the colour cell given by (row,col)
+BOOL CColourPopup::GetCellRect(int nIndex, const LPRECT& rect)
+{
+    if (nIndex == CUSTOM_BOX_VALUE)
+    {
+        ::SetRect(rect, 
+                  m_CustomTextRect.left,  m_CustomTextRect.top,
+                  m_CustomTextRect.right, m_CustomTextRect.bottom);
+        return TRUE;
+    }
+    else if (nIndex == DEFAULT_BOX_VALUE)
+    {
+        ::SetRect(rect, 
+                  m_DefaultTextRect.left,  m_DefaultTextRect.top,
+                  m_DefaultTextRect.right, m_DefaultTextRect.bottom);
+        return TRUE;
+    }
+
+    if (nIndex < 0 || nIndex >= m_nNumColours)
+        return FALSE;
+
+    rect->left = GetColumn(nIndex) * m_nBoxSize + m_nMargin;
+    rect->top  = GetRow(nIndex) * m_nBoxSize + m_nMargin;
+
+    // Move everything down if we are displaying a default text area
+    if (m_strDefaultText.GetLength()) 
+        rect->top += (m_nMargin + m_DefaultTextRect.Height());
+
+    rect->right = rect->left + m_nBoxSize;
+    rect->bottom = rect->top + m_nBoxSize;
+
+    return TRUE;
+}
+
+// Works out an appropriate size and position of this window
+void CColourPopup::SetWindowSize()
+{
+    CSize TextSize;
+
+    // If we are showing a custom or default text area, get the font and text size.
+    if (m_strCustomText.GetLength() || m_strDefaultText.GetLength())
+    {
+        CClientDC dc(m_hWnd);
+        HFONT pOldFont =  dc.SelectFont(m_Font);
+
+        // Get the size of the custom text (if there IS custom text)
+        TextSize = CSize(0,0);
+        if (m_strCustomText.GetLength())
+            dc.GetTextExtent(m_strCustomText,m_strCustomText.GetLength(),&TextSize);
+
+        // Get the size of the default text (if there IS default text)
+        if (m_strDefaultText.GetLength())
+        {
+            CSize DefaultSize;
+			dc.GetTextExtent(m_strDefaultText,m_strDefaultText.GetLength(),&DefaultSize);
+            if (DefaultSize.cx > TextSize.cx) TextSize.cx = DefaultSize.cx;
+            if (DefaultSize.cy > TextSize.cy) TextSize.cy = DefaultSize.cy;
+        }
+
+        dc.SelectFont(pOldFont);
+        TextSize += CSize(2*m_nMargin,2*m_nMargin);
+
+        // Add even more space to draw the horizontal line
+        TextSize.cy += 2*m_nMargin + 2;
+    }
+
+    // Get the number of columns and rows
+    //m_nNumColumns = (int) sqrt((double)m_nNumColours);    // for a square window (yuk)
+    m_nNumColumns = 8;
+    m_nNumRows = m_nNumColours / m_nNumColumns;
+    if (m_nNumColours % m_nNumColumns) m_nNumRows++;
+
+    // Get the current window position, and set the new size
+    CRect rect;
+    GetWindowRect(rect);
+
+    m_WindowRect.SetRect(rect.left, rect.top, 
+                         rect.left + m_nNumColumns*m_nBoxSize + 2*m_nMargin,
+                         rect.top  + m_nNumRows*m_nBoxSize + 2*m_nMargin);
+
+    // if custom text, then expand window if necessary, and set text width as
+    // window width
+    if (m_strDefaultText.GetLength()) 
+    {
+        if (TextSize.cx > m_WindowRect.Width())
+            m_WindowRect.right = m_WindowRect.left + TextSize.cx;
+        TextSize.cx = m_WindowRect.Width()-2*m_nMargin;
+
+        // Work out the text area
+        m_DefaultTextRect.SetRect(m_nMargin, m_nMargin, 
+                                  m_nMargin+TextSize.cx, 2*m_nMargin+TextSize.cy);
+        m_WindowRect.bottom += m_DefaultTextRect.Height() + 2*m_nMargin;
+    }
+
+    // if custom text, then expand window if necessary, and set text width as
+    // window width
+    if (m_strCustomText.GetLength()) 
+    {
+        if (TextSize.cx > m_WindowRect.Width())
+            m_WindowRect.right = m_WindowRect.left + TextSize.cx;
+        TextSize.cx = m_WindowRect.Width()-2*m_nMargin;
+
+        // Work out the text area
+        m_CustomTextRect.SetRect(m_nMargin, m_WindowRect.Height(), 
+                                 m_nMargin+TextSize.cx, 
+                                 m_WindowRect.Height()+m_nMargin+TextSize.cy);
+        m_WindowRect.bottom += m_CustomTextRect.Height() + 2*m_nMargin;
+   }
+
+    // Need to check it'll fit on screen: Too far right?
+    CSize ScreenSize(::GetSystemMetrics(SM_CXSCREEN), ::GetSystemMetrics(SM_CYSCREEN));
+    if (m_WindowRect.right > ScreenSize.cx)
+        m_WindowRect.OffsetRect(-(m_WindowRect.right - ScreenSize.cx), 0);
+
+    // Too far left?
+    if (m_WindowRect.left < 0)
+        m_WindowRect.OffsetRect( -m_WindowRect.left, 0);
+
+    // Bottom falling out of screen?
+    if (m_WindowRect.bottom > ScreenSize.cy)
+    {
+        CRect ParentRect;
+//         m_pParent->GetWindowRect(ParentRect);
+//         m_WindowRect.OffsetRect(0, -(ParentRect.Height() + m_WindowRect.Height()));
+    }
+
+    // Set the window size and position
+    MoveWindow(m_WindowRect, TRUE);
+}
+
+void CColourPopup::CreateToolTips()
+{
+    // Create the tool tip
+    if (!m_ToolTip.Create(m_hWnd,0)) return;
+	
+    // Add a tool for each cell
+    for (int i = 0; i < m_nNumColours; i++)
+    {
+        CRect rect;
+         if (!GetCellRect(i, rect)) continue;
+         m_ToolTip.AddTool(m_hWnd, GetColourName(i), rect, 1);
+    }
+}
+
+void CColourPopup::ChangeSelection(int nIndex)
+{
+    CClientDC dc(m_hWnd);        // device context for drawing
+
+    if (nIndex > m_nNumColours)
+        nIndex = CUSTOM_BOX_VALUE; 
+
+    if ((m_nCurrentSel >= 0 && m_nCurrentSel < m_nNumColours) ||
+        m_nCurrentSel == CUSTOM_BOX_VALUE || m_nCurrentSel == DEFAULT_BOX_VALUE)
+    {
+        // Set Current selection as invalid and redraw old selection (this way
+        // the old selection will be drawn unselected)
+        int OldSel = m_nCurrentSel;
+        m_nCurrentSel = INVALID_COLOUR;
+        DrawCell(&dc, OldSel);
+    }
+
+    // Set the current selection as row/col and draw (it will be drawn selected)
+    m_nCurrentSel = nIndex;
+    DrawCell(&dc, m_nCurrentSel);
+
+    // Store the current colour
+     if (m_nCurrentSel == CUSTOM_BOX_VALUE) m_crColour=m_crInitialColour;
+	 else if(m_nCurrentSel == DEFAULT_BOX_VALUE) m_crColour=m_crDef;
+	 else m_crColour=GetColour(m_nCurrentSel);
+	 if(m_pColorPicker)
+		m_pColorPicker->OnColorChanged(m_crColour);
+}
+
+void CColourPopup::EndSelection(int nMessage)
+{
+    ReleaseCapture();
+
+    // If custom text selected, perform a custom colour selection
+    if (nMessage != IDCANCEL && m_nCurrentSel == CUSTOM_BOX_VALUE)
+    {
+		ShowWindow(SW_HIDE);
+		MyChooseColor(m_crColour);
+    }
+
+    if (nMessage == IDCANCEL)
+        m_crColour = m_crInitialColour;
+
+	if(m_pColorPicker)
+		m_pColorPicker->OnColorEnd(nMessage==IDCANCEL,m_crColour);
+
+    DestroyWindow();
+}
+
+void CColourPopup::DrawCell(CDC* pDC, int nIndex)
+{
+    // For the Custom Text area
+    if (m_strCustomText.GetLength() && nIndex == CUSTOM_BOX_VALUE)
+    {
+        // The extent of the actual text button
+        CRect TextButtonRect = m_CustomTextRect;
+        TextButtonRect.top += 2*m_nMargin;
+
+        // Fill background
+        pDC->FillSolidRect(TextButtonRect, ::GetSysColor(COLOR_3DFACE));
+
+        // Draw horizontal line
+        pDC->FillSolidRect(m_CustomTextRect.left+2*m_nMargin, m_CustomTextRect.top,
+                           m_CustomTextRect.Width()-4*m_nMargin, 1, ::GetSysColor(COLOR_3DSHADOW));
+        pDC->FillSolidRect(m_CustomTextRect.left+2*m_nMargin, m_CustomTextRect.top+1,
+                           m_CustomTextRect.Width()-4*m_nMargin, 1, ::GetSysColor(COLOR_3DHILIGHT));
+
+        TextButtonRect.DeflateRect(1,1);
+
+        // fill background
+        if (m_nChosenColourSel == nIndex && m_nCurrentSel != nIndex)
+            pDC->FillSolidRect(TextButtonRect, ::GetSysColor(COLOR_3DLIGHT));
+        else
+            pDC->FillSolidRect(TextButtonRect, ::GetSysColor(COLOR_3DFACE));
+
+        // Draw button
+        if (m_nCurrentSel == nIndex) 
+            pDC->DrawEdge(TextButtonRect, BDR_RAISEDINNER, BF_RECT);
+        else if (m_nChosenColourSel == nIndex)
+            pDC->DrawEdge(TextButtonRect, BDR_SUNKENOUTER, BF_RECT);
+
+        // Draw custom text
+        HFONT pOldFont= pDC->SelectFont(m_Font);
+        pDC->SetBkMode(TRANSPARENT);
+        pDC->DrawText(m_strCustomText,m_strCustomText.GetLength(), TextButtonRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
+        pDC->SelectFont(pOldFont);
+
+        return;
+    }        
+
+    // For the Default Text area
+    if (m_strDefaultText.GetLength() && nIndex == DEFAULT_BOX_VALUE)
+    {
+        // Fill background
+        pDC->FillSolidRect(m_DefaultTextRect, ::GetSysColor(COLOR_3DFACE));
+
+        // The extent of the actual text button
+        CRect TextButtonRect = m_DefaultTextRect;
+        TextButtonRect.DeflateRect(1,1);
+
+        // fill background
+        if (m_nChosenColourSel == nIndex && m_nCurrentSel != nIndex)
+            pDC->FillSolidRect(TextButtonRect, ::GetSysColor(COLOR_3DLIGHT));
+        else
+            pDC->FillSolidRect(TextButtonRect, ::GetSysColor(COLOR_3DFACE));
+
+        // Draw thin line around text
+        CRect LineRect = TextButtonRect;
+        LineRect.DeflateRect(2*m_nMargin,2*m_nMargin);
+        CPen pen;
+		pen.CreatePen(PS_SOLID, 1, ::GetSysColor(COLOR_3DSHADOW));
+        HPEN pOldPen = pDC->SelectPen(pen);
+        pDC->SelectBrush((HBRUSH)GetStockObject(NULL_BRUSH));
+        pDC->Rectangle(LineRect);
+        pDC->SelectPen(pOldPen);
+
+        // Draw button
+        if (m_nCurrentSel == nIndex) 
+            pDC->DrawEdge(TextButtonRect, BDR_RAISEDINNER, BF_RECT);
+        else if (m_nChosenColourSel == nIndex)
+            pDC->DrawEdge(TextButtonRect, BDR_SUNKENOUTER, BF_RECT);
+
+        // Draw custom text
+        HFONT pOldFont = pDC->SelectFont(m_Font);
+        pDC->SetBkMode(TRANSPARENT);
+        pDC->DrawText(m_strDefaultText,m_strDefaultText.GetLength(), TextButtonRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
+        pDC->SelectFont(pOldFont);
+
+        return;
+    }        
+
+    CRect rect;
+    if (!GetCellRect(nIndex, rect)) return;
+
+    // fill background
+    if (m_nChosenColourSel == nIndex && m_nCurrentSel != nIndex)
+        pDC->FillSolidRect(rect, ::GetSysColor(COLOR_3DHILIGHT));
+    else
+        pDC->FillSolidRect(rect, ::GetSysColor(COLOR_3DFACE));
+
+    // Draw button
+    if (m_nCurrentSel == nIndex) 
+        pDC->DrawEdge(rect, BDR_RAISEDINNER, BF_RECT);
+    else if (m_nChosenColourSel == nIndex)
+        pDC->DrawEdge(rect, BDR_SUNKENOUTER, BF_RECT);
+
+    CBrush brush(RGB(GetRValue(GetColour(nIndex)), 
+                            GetGValue(GetColour(nIndex)), 
+                            GetBValue(GetColour(nIndex)) ));
+    CPen   pen;
+    pen.CreatePen(PS_SOLID, 1, ::GetSysColor(COLOR_3DSHADOW));
+
+    HBRUSH pOldBrush =  pDC->SelectBrush(brush);
+    HPEN   pOldPen   =    pDC->SelectPen(pen);
+
+    // Draw the cell colour
+    rect.DeflateRect(m_nMargin+1, m_nMargin+1);
+    pDC->Rectangle(rect);
+
+    // restore DC and cleanup
+    pDC->SelectBrush(pOldBrush);
+    pDC->SelectPen(pOldPen);
+    brush.DeleteObject();
+    pen.DeleteObject();
+
+}
+
+void CColourPopup::OnKillFocus(HWND hNewWnd) 
+{
+    ReleaseCapture();
+}
+
+
+// KillFocus problem fix suggested by Paul Wilkerson.
+void CColourPopup::OnActivateApp(BOOL bActive, DWORD hTask) 
+{
+	DefWindowProc();
+	// If Deactivating App, cancel this selection
+	if (!bActive)	EndSelection(IDCANCEL);
+}
+
+void CColourPopup::OnFinalMessage( HWND hWnd )
+{
+	delete this;
+}
+
+BOOL CColourPopup::MyChooseColor(COLORREF &cr)
+{
+	CHOOSECOLOR cc;                 // common dialog box structure 
+	static COLORREF acrCustClr[16]; // array of custom colors 
+
+	// Initialize CHOOSECOLOR 
+	ZeroMemory(&cc, sizeof(cc));
+	cc.lStructSize = sizeof(cc);
+	cc.hwndOwner = m_hWnd;
+	cc.lpCustColors = (LPDWORD) acrCustClr;
+	cc.rgbResult = cr;
+	cc.Flags = CC_FULLOPEN | CC_RGBINIT;
+
+	if (!ChooseColor(&cc)) return FALSE;
+
+	cr=cc.rgbResult;
+	return TRUE;
+}
+
+}//end of namespace
Index: colorpicker/ColourPopup.h
===================================================================
--- colorpicker/ColourPopup.h	(revision 0)
+++ colorpicker/ColourPopup.h	(working copy)
@@ -0,0 +1,121 @@
+#ifndef COLOURPOPUP_INCLUDED
+#define COLOURPOPUP_INCLUDED
+#pragma once 
+
+
+// ColourPopup.h : header file
+//
+// Written by Chris Maunder (chrismaunder@codeguru.com)
+// Extended by Alexander Bischofberger (bischofb@informatik.tu-muenchen.de)
+// Copyright (c) 1998.
+//
+// This code may be used in compiled form in any way you desire. This
+// file may be redistributed unmodified by any means PROVIDING it is 
+// not sold for profit without the authors written consent, and 
+// providing that this notice and the authors name is included. If 
+// the source code in  this file is used in any commercial application 
+// then a simple email would be nice.
+//
+// This file is provided "as is" with no expressed or implied warranty.
+// The author accepts no liability if it causes any damage whatsoever.
+// It's free - so you get what you pay for.
+
+#include "tooltipctrl.h"
+
+namespace DuiEngine
+{
+
+struct IColorPicker{
+	virtual void OnColorChanged(COLORREF cr)=0;
+	virtual void OnColorEnd(BOOL bCancel,COLORREF cr)=0;
+};
+
+/////////////////////////////////////////////////////////////////////////////
+// CColourPopup window
+
+class CColourPopup : public CSimpleWnd , public CDuiMessageFilter
+{
+	// To hold the colours and their names
+	typedef struct {
+		COLORREF crColour;
+		TCHAR    *szName;
+	} ColourTableEntry;
+// Construction
+public:
+    CColourPopup(HWND hOwner,IColorPicker *pColorPicker);
+
+	virtual ~CColourPopup();
+
+// Operations
+public:
+    BOOL Create(CPoint p, COLORREF crColour, LPCTSTR szDefaultText = NULL, LPCTSTR szCustomText = NULL);
+
+	void SetDefColor(COLORREF crDef){m_crDef=crDef;}
+public:
+    virtual BOOL PreTranslateMessage(MSG* pMsg);
+
+protected:
+	void Initialise();
+    BOOL GetCellRect(int nIndex, const LPRECT& rect);
+    void FindCellFromColour(COLORREF crColour);
+    void SetWindowSize();
+    void CreateToolTips();
+    void ChangeSelection(int nIndex);
+    void EndSelection(int nMessage);
+    void DrawCell(CDC* pDC, int nIndex);
+
+    COLORREF GetColour(int nIndex)              { return m_crColours[nIndex].crColour; }
+    LPCTSTR GetColourName(int nIndex)           { return m_crColours[nIndex].szName; }
+    int  GetIndex(int row, int col) const;
+    int  GetRow(int nIndex) const;
+    int  GetColumn(int nIndex) const;
+
+	BOOL MyChooseColor(COLORREF &cr);
+
+// protected attributes
+protected:
+    static ColourTableEntry m_crColours[];
+    int            m_nNumColours;
+    int            m_nNumColumns, m_nNumRows;
+    int            m_nBoxSize, m_nMargin;
+    int            m_nCurrentSel;
+    int            m_nChosenColourSel;
+    CDuiStringT        m_strDefaultText;
+    CDuiStringT        m_strCustomText;
+    CRect          m_CustomTextRect, m_DefaultTextRect, m_WindowRect;
+    CFont          m_Font;
+    CPalette       m_Palette;
+    COLORREF       m_crInitialColour, m_crColour;
+	COLORREF		m_crDef;
+    CSimpleToolTip   m_ToolTip;
+
+	HWND			m_hOwner;
+	IColorPicker	*m_pColorPicker;
+    // Generated message map functions
+protected:
+    void OnLButtonUp(UINT nFlags, CPoint point);
+    void OnPaint(HDC hdc);
+    void OnMouseMove(UINT nFlags, CPoint point);
+    void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
+	void OnKillFocus(HWND hNewWnd);
+	void OnActivateApp(BOOL bActive, DWORD hTask);
+
+	virtual void OnFinalMessage(HWND hWnd);
+
+	BEGIN_MSG_MAP_EX(CColourPopup)
+		MSG_WM_LBUTTONUP(OnLButtonUp)
+		MSG_WM_PAINT(OnPaint)
+		MSG_WM_MOUSEMOVE(OnMouseMove)
+		MSG_WM_KEYDOWN(OnKeyDown)
+		MSG_WM_KILLFOCUS(OnKillFocus)
+		MSG_WM_ACTIVATEAPP(OnActivateApp)
+	END_MSG_MAP()
+};
+
+
+}//end of namespace
+
+/////////////////////////////////////////////////////////////////////////////
+
+
+#endif // !defined(AFX_COLOURPOPUP_H__D0B75902_9830_11D1_9C0F_00A0243D1382__INCLUDED_)
Index: colorpicker/DuiColorPicker.cpp
===================================================================
--- colorpicker/DuiColorPicker.cpp	(revision 0)
+++ colorpicker/DuiColorPicker.cpp	(working copy)
@@ -0,0 +1,60 @@
+#include "StdAfx.h"
+#include "DuiColorPicker.h"
+
+namespace DuiEngine
+{
+
+CDuiColorPicker::CDuiColorPicker(void):m_crDef(0),m_crCur(0)
+{
+}
+
+CDuiColorPicker::~CDuiColorPicker(void)
+{
+}
+
+void CDuiColorPicker::OnPaint( CDCHandle dc )
+{
+	CRect rcClient;
+	GetClient(&rcClient);
+	ALPHAINFO ai;
+	CGdiAlpha::AlphaBackup(dc,rcClient,ai);
+	dc.FillSolidRect(&rcClient,m_crCur);
+	dc.DrawEdge(&rcClient, BDR_RAISEDINNER, BF_RECT);
+	CGdiAlpha::AlphaRestore(dc,ai);
+}
+
+void CDuiColorPicker::OnLButtonUp( UINT nFlags,CPoint pt )
+{
+	__super::OnLButtonUp(nFlags,pt);
+	CColourPopup *pCrPopup = new CColourPopup(GetContainer()->GetHostHwnd(),this);
+	CRect rcWnd;
+	GetRect(rcWnd);
+	pt.x=rcWnd.left,pt.y=rcWnd.bottom;
+	::ClientToScreen(GetContainer()->GetHostHwnd(),&pt);
+	pCrPopup->SetDefColor(m_crDef);
+	pCrPopup->Create(pt,m_crCur,_T("Ä¬ÈÏ"),_T("¸ü¶à"));
+}
+
+void CDuiColorPicker::OnColorChanged( COLORREF cr )
+{
+	m_crCur=cr;
+	NotifyInvalidate();
+
+}
+
+void CDuiColorPicker::OnColorEnd( BOOL bCancel,COLORREF cr )
+{
+	if(bCancel) m_crCur=m_crDef;
+	else m_crCur=cr;
+	ModifyState(0,DuiWndState_PushDown,TRUE);
+	DUINMCOLORCHANGE nm;
+	nm.hdr.code=DUINM_COLORCHANGE;
+	nm.hdr.hDuiWnd=m_hDuiWnd;
+	nm.hdr.idFrom=m_uCmdID;
+	nm.hdr.pszNameFrom=GetName();
+	nm.crSel=m_crCur;
+
+	DuiNotify((LPDUINMHDR)&nm);
+}
+
+}//end of namespace
\ No newline at end of file
Index: colorpicker/DuiColorPicker.h
===================================================================
--- colorpicker/DuiColorPicker.h	(revision 0)
+++ colorpicker/DuiColorPicker.h	(working copy)
@@ -0,0 +1,44 @@
+#pragma once
+#include "ColourPopup.h"
+
+namespace DuiEngine
+{
+#define DUINM_COLORCHANGE	100
+
+	typedef struct tagDUINMCOLORCHANGE
+	{
+		DUINMHDR hdr;
+		COLORREF crSel;
+	}DUINMCOLORCHANGE,*LPDUINMCOLORCHANGE;
+
+class CDuiColorPicker :
+	public CDuiButton ,
+	public IColorPicker
+{
+	DUIOBJ_DECLARE_CLASS_NAME(CDuiColorPicker, "colorpicker")
+
+public:
+	CDuiColorPicker(void);
+	~CDuiColorPicker(void);
+
+protected://IColorPicker
+	virtual void OnColorChanged(COLORREF cr);
+	virtual void OnColorEnd(BOOL bCancel,COLORREF cr);
+protected:
+	void OnPaint(CDCHandle dc);
+	void OnLButtonUp(UINT nFlags,CPoint pt);
+
+	DUIWIN_BEGIN_MSG_MAP()
+		MSG_WM_PAINT(OnPaint)
+		MSG_WM_LBUTTONUP(OnLButtonUp)
+	DUIWIN_END_MSG_MAP()
+
+	DUIWIN_DECLARE_ATTRIBUTES_BEGIN()
+		DUIWIN_COLOR_ATTRIBUTE("color",m_crCur=m_crDef,TRUE)
+	DUIWIN_DECLARE_ATTRIBUTES_END()
+	
+	COLORREF	m_crDef;
+	COLORREF	m_crCur;
+};
+
+}
Index: colorpicker/Tooltipctrl.h
===================================================================
--- colorpicker/Tooltipctrl.h	(revision 0)
+++ colorpicker/Tooltipctrl.h	(working copy)
@@ -0,0 +1,76 @@
+#pragma once
+
+#include <SimpleWnd.h>
+
+namespace DuiEngine{
+
+typedef struct tagAFX_OLDTOOLINFO1 {
+	UINT cbSize;
+	UINT uFlags;
+	HWND hwnd;
+	UINT uId;
+	RECT rect;
+	HINSTANCE hinst;
+	LPTSTR lpszText;
+} AFX_OLDTOOLINFO1;
+
+class CSimpleToolTip : public CSimpleWnd
+{
+public:
+	BOOL Create(HWND hParent,DWORD dwExStyle,HINSTANCE hInst=NULL)
+	{
+		HWND hWnd=::CreateWindowEx(dwExStyle,TOOLTIPS_CLASS,NULL,WS_POPUP,0,0,0,0,hParent,0,hInst,0);
+		if(!hWnd) return FALSE;
+		return SubclassWindow(hWnd);
+	}
+
+	BOOL AddTool(HWND hWnd, LPCTSTR lpszText, LPCRECT lpRectTool,
+		UINT_PTR nIDTool)
+	{
+		DUIASSERT(::IsWindow(m_hWnd));
+		DUIASSERT(::IsWindow(hWnd));
+		DUIASSERT(lpszText != NULL);
+		// the toolrect and toolid must both be zero or both valid
+		DUIASSERT((lpRectTool != NULL && nIDTool != 0) ||
+			(lpRectTool == NULL) && (nIDTool == 0));
+
+		TOOLINFO ti;
+		FillInToolInfo(ti, hWnd, nIDTool);
+		if (lpRectTool != NULL)
+		{
+			ti.rect=*lpRectTool;
+		}
+
+		ti.lpszText = (LPTSTR)lpszText;
+		return (BOOL) ::SendMessage(m_hWnd, TTM_ADDTOOL, 0, (LPARAM)&ti);
+	}
+
+	void RelayEvent(LPMSG lpMsg)
+	{ 
+		DUIASSERT(::IsWindow(m_hWnd)); 
+		::SendMessage(m_hWnd, TTM_RELAYEVENT, 0, (LPARAM)lpMsg); 
+	}
+
+protected:
+	void FillInToolInfo(TOOLINFO& ti, HWND hwnd, UINT_PTR nIDTool) const
+	{
+		memset(&ti, 0, sizeof(TOOLINFO));
+		ti.cbSize = sizeof(AFX_OLDTOOLINFO1);
+		if (nIDTool == 0)
+		{
+			ti.hwnd = ::GetParent(hwnd);
+			ti.uFlags = TTF_IDISHWND;
+			ti.uId = (UINT_PTR)hwnd;
+		}
+		else
+		{
+			ti.hwnd = hwnd;
+			ti.uFlags = 0;
+			ti.uId = nIDTool;
+		}
+	}
+
+};
+
+
+}//end of namespace
Index: duires/winres.rc2
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: ImgView.h
===================================================================
--- ImgView.h	(revision 127)
+++ ImgView.h	(working copy)
@@ -29,6 +29,8 @@
 		void SetTile(BOOL bTile);
 
 		void SetVertical(BOOL bVertical);
+
+		CDuiSkinButton * GetButtonSkin(){return &m_skinButton;}
 	private:
 		CDuiSkinBase * GetSkin();
 
Index: NewSkinDlg.cpp
===================================================================
--- NewSkinDlg.cpp	(revision 127)
+++ NewSkinDlg.cpp	(working copy)
@@ -194,3 +194,83 @@
 	}
 	EndDialog(IDOK);
 }
+
+LRESULT CNewSkinDlg::OnCrChange_Button_Border( LPDUINMHDR pNHdr )
+{
+	LPDUINMCOLORCHANGE pNmColor=(LPDUINMCOLORCHANGE)pNHdr;
+	SetButtonSkinColor("border",pNmColor->crSel);
+	return S_OK;
+}
+
+LRESULT CNewSkinDlg::OnCrChange_Button_Normal_Up( LPDUINMHDR pNHdr )
+{
+	LPDUINMCOLORCHANGE pNmColor=(LPDUINMCOLORCHANGE)pNHdr;
+	SetButtonSkinColor("bgup",pNmColor->crSel);
+	return S_OK;
+}
+
+
+LRESULT CNewSkinDlg::OnCrChange_Button_Normal_Down( LPDUINMHDR pNHdr )
+{
+	LPDUINMCOLORCHANGE pNmColor=(LPDUINMCOLORCHANGE)pNHdr;
+	SetButtonSkinColor("bgdown",pNmColor->crSel);
+	return S_OK;
+}
+
+
+LRESULT CNewSkinDlg::OnCrChange_Button_Hover_Up( LPDUINMHDR pNHdr )
+{
+	LPDUINMCOLORCHANGE pNmColor=(LPDUINMCOLORCHANGE)pNHdr;
+	SetButtonSkinColor("bguphover",pNmColor->crSel);
+	return S_OK;
+}
+
+
+LRESULT CNewSkinDlg::OnCrChange_Button_Hover_Down( LPDUINMHDR pNHdr )
+{
+	LPDUINMCOLORCHANGE pNmColor=(LPDUINMCOLORCHANGE)pNHdr;
+	SetButtonSkinColor("bgdownhover",pNmColor->crSel);
+	return S_OK;
+}
+
+
+LRESULT CNewSkinDlg::OnCrChange_Button_Pushdown_Up( LPDUINMHDR pNHdr )
+{
+	LPDUINMCOLORCHANGE pNmColor=(LPDUINMCOLORCHANGE)pNHdr;
+	SetButtonSkinColor("bguppush",pNmColor->crSel);
+	return S_OK;
+}
+
+
+LRESULT CNewSkinDlg::OnCrChange_Button_Pushdown_Down( LPDUINMHDR pNHdr )
+{
+	LPDUINMCOLORCHANGE pNmColor=(LPDUINMCOLORCHANGE)pNHdr;
+	SetButtonSkinColor("bgdownpush",pNmColor->crSel);
+	return S_OK;
+}
+
+
+LRESULT CNewSkinDlg::OnCrChange_Button_Disable_Up( LPDUINMHDR pNHdr )
+{
+	LPDUINMCOLORCHANGE pNmColor=(LPDUINMCOLORCHANGE)pNHdr;
+	SetButtonSkinColor("bgupdisable",pNmColor->crSel);
+	return S_OK;
+}
+
+
+LRESULT CNewSkinDlg::OnCrChange_Button_Disable_Down( LPDUINMHDR pNHdr )
+{
+	LPDUINMCOLORCHANGE pNmColor=(LPDUINMCOLORCHANGE)pNHdr;
+	SetButtonSkinColor("bgdowndisable",pNmColor->crSel);
+	return S_OK;
+}
+
+void CNewSkinDlg::SetButtonSkinColor( const CDuiStringA &strAttr,COLORREF cr )
+{
+	CImgView *pImgView=FindChildByName2<CImgView*>("imgview_button");
+	DUIASSERT(pImgView);
+	CDuiStringA strColor;
+	strColor.Format("%02x%02x%02x",GetRValue(cr),GetGValue(cr),GetBValue(cr));
+	pImgView->GetButtonSkin()->SetAttribute(strAttr,strColor);
+	pImgView->NotifyInvalidate();
+}
\ No newline at end of file
Index: NewSkinDlg.h
===================================================================
--- NewSkinDlg.h	(revision 127)
+++ NewSkinDlg.h	(working copy)
@@ -17,6 +17,17 @@
 	LRESULT OnEditNotify_imglst(LPDUINMHDR pNHdr);
 	LRESULT OnEditNotify_imgframe(LPDUINMHDR pNHdr);
 
+	LRESULT OnCrChange_Button_Border(LPDUINMHDR pNHdr);
+	LRESULT OnCrChange_Button_Normal_Up(LPDUINMHDR pNHdr);
+	LRESULT OnCrChange_Button_Normal_Down(LPDUINMHDR pNHdr);
+	LRESULT OnCrChange_Button_Hover_Up(LPDUINMHDR pNHdr);
+	LRESULT OnCrChange_Button_Hover_Down(LPDUINMHDR pNHdr);
+	LRESULT OnCrChange_Button_Pushdown_Up(LPDUINMHDR pNHdr);
+	LRESULT OnCrChange_Button_Pushdown_Down(LPDUINMHDR pNHdr);
+	LRESULT OnCrChange_Button_Disable_Up(LPDUINMHDR pNHdr);
+	LRESULT OnCrChange_Button_Disable_Down(LPDUINMHDR pNHdr);
+	void SetButtonSkinColor(const CDuiStringA &strAttr,COLORREF cr);
+
 	void OnOK();
 
 	DUI_NOTIFY_MAP_BEGIN()
@@ -31,6 +42,19 @@
 		DUI_NOTIFY_NAME_COMMAND("chk_imgframe_vert",UpdateImgframePreview)
 		DUI_NOTIFY_NAME_COMMAND("chk_imgframe_tile",UpdateImgframePreview)
 
+		DUI_NOTIFY_NAME_HANDLER("edit_imgframe_frame",DUINM_RICHEDIT_NOTIFY,OnEditNotify_imgframe)
+
+		DUI_NOTIFY_NAME_HANDLER("crpk_bt1_up",DUINM_COLORCHANGE,OnCrChange_Button_Normal_Up)
+		DUI_NOTIFY_NAME_HANDLER("crpk_bt1_down",DUINM_COLORCHANGE,OnCrChange_Button_Normal_Down)
+		DUI_NOTIFY_NAME_HANDLER("crpk_bt2_up",DUINM_COLORCHANGE,OnCrChange_Button_Hover_Up)
+		DUI_NOTIFY_NAME_HANDLER("crpk_bt2_down",DUINM_COLORCHANGE,OnCrChange_Button_Hover_Down)
+		DUI_NOTIFY_NAME_HANDLER("crpk_bt3_up",DUINM_COLORCHANGE,OnCrChange_Button_Pushdown_Up)
+		DUI_NOTIFY_NAME_HANDLER("crpk_bt3_down",DUINM_COLORCHANGE,OnCrChange_Button_Pushdown_Down)
+		DUI_NOTIFY_NAME_HANDLER("crpk_bt4_up",DUINM_COLORCHANGE,OnCrChange_Button_Disable_Up)
+		DUI_NOTIFY_NAME_HANDLER("crpk_bt4_down",DUINM_COLORCHANGE,OnCrChange_Button_Disable_Down)
+		DUI_NOTIFY_NAME_HANDLER("crpk_bt_border",DUINM_COLORCHANGE,OnCrChange_Button_Border)
+
+
 		DUI_NOTIFY_ID_COMMAND(IDOK,OnOK)
 	DUI_NOTIFY_MAP_END()	
 
Index: skin/xml/dlg_main.xml
===================================================================
--- skin/xml/dlg_main.xml	(revision 127)
+++ skin/xml/dlg_main.xml	(working copy)
@@ -30,6 +30,7 @@
                   </header>
                 </listctrl>
                 <button name="prg_btn_add_file" pos="0,-25,100,-0">å¢å æä»¶</button>
+                <colorpicker name="crpk_test" pos="110,-25,125,-10" color="ff0000"/>
               </tab>
               <tab title="skins view">
                 <!--é¡¹ç®ç®è¤åè¡¨-->
Index: skin/xml/dlg_newskin.xml
===================================================================
--- skin/xml/dlg_newskin.xml	(revision 127)
+++ skin/xml/dlg_newskin.xml	(working copy)
@@ -3,7 +3,7 @@
     <dlg name="maindlg" pos="0,0,-0,-0" class="cls_dlg_frame">
       <caption id="101" pos="0,0,-0,29">
         <text pos="11,9" class="cls_txt_red">Insert New Skin</text>
-        <imgbtn id="1" name="btn_sys_close" skin="btn_sys_close"    pos="-45,0" tip="close" animate="1"/>
+        <imgbtn id="2" name="btn_sys_close" skin="btn_sys_close"    pos="-45,0" tip="close" animate="1"/>
       </caption>
       <dlg pos="5,29,-5,-5" crtext="000000">
         <tabctrl name="tab_skin_type" pos="0,0,-0,-50" tabpos="150">
@@ -36,7 +36,35 @@
             <imgview name="imgview_scrollbar" pos="0,80,-0,-0" viewtype="scrollbar"/>
           </tab>
           <tab title="button">
-            <imgview name="imgview_scrollbar" pos="0,80,-0,-0" viewtype="button"/>
+            <group pos="0,0" width="90" height="70">æ­£å¸¸ç¶æ
+              <text pos="5,20">é¢è²ä¸</text>
+              <colorpicker pos="[5,[-12" width="12" height="12" name="crpk_bt1_up" color="FEFEFE"/>
+              <text pos="5,40">é¢è²ä¸</text>
+              <colorpicker pos="[5,[-12" width="12" height="12" name="crpk_bt1_down" color="C6E2FD"/>
+            </group>
+
+            <group width="90" height="70">æµ®èµ·ç¶æ
+              <text pos="5,20">é¢è²ä¸</text>
+              <colorpicker pos="[5,[-12" width="12" height="12" name="crpk_bt2_up" color="FEFEFE"/>
+              <text pos="5,40">é¢è²ä¸</text>
+              <colorpicker pos="[5,[-12" width="12" height="12" name="crpk_bt2_down" color="DBEDFE"/>
+            </group>
+            <group width="90" height="70">æä¸ç¶æ
+              <text pos="5,20">é¢è²ä¸</text>
+              <colorpicker pos="[5,[-12" width="12" height="12" name="crpk_bt3_up" color="FEFEFE"/>
+              <text pos="5,40">é¢è²ä¸</text>
+              <colorpicker pos="[5,[-12" width="12" height="12" name="crpk_bt3_down" color="DBEDFE"/>
+            </group>
+            <group width="90" height="70">ç¦ç¨ç¶æ
+              <text pos="5,20">é¢è²ä¸</text>
+              <colorpicker pos="[5,[-12" width="12" height="12" name="crpk_bt4_up" color="8e8e8e"/>
+              <text pos="5,40">é¢è²ä¸</text>
+              <colorpicker pos="[5,[-12" width="12" height="12" name="crpk_bt4_down" color="808080"/>
+            </group>
+            <text pos="5,80">è¾¹ç¼é¢è²</text>
+            <colorpicker pos="[5,[-12" width="12" height="12" name="crpk_bt_border" color="707070"/>
+
+            <imgview name="imgview_button" pos="0,100,-0,-0" viewtype="button"/>
           </tab>
         </tabctrl>
         
Index: skin/xml/init.xml
===================================================================
--- skin/xml/init.xml	(revision 127)
+++ skin/xml/init.xml	(working copy)
@@ -1,76 +1,56 @@
-ï»¿<DuiEngine>
-  <font face="å®ä½" size="12"/>
-
-  <string>
-    <s id="1">SoUIEditor</s>
-    <s id="2">1.0</s>
-  </string>
-
-  <skins>
-    <imgframe name="dlg_frame" src="IDP_MAIN_DLG_FRAME" left="5" right="5" top="40" bottom="40"/>
-
-    <imglst name="btncheckbox"         src="IDP_BTN_WND_CHECKBOX" states="8"  />
-    <imglst name="btnRadio"            src="IDP_BTN_WND_RADIO" states="8"  />
-    <imglst name="focuscheckbox" src="IDP_FOCUS_CHECK"/>
-    <imglst name="focusRadio" src="IDP_FOCUS_RADIO"/>
-    <scrollbar name="sb_common" src="IDP_SCROLL" margin="3"/>
-
-    <imglst name="btn_sys_close"    src="IDP_BTN_SYS_CLOSE" states="3" />
-    <imglst name="btn_sys_minimize" src="IDP_BTN_SYS_MINIMIZE" states="3" />
-    <imglst name="btn_sys_maximize" src="IDP_BTN_SYS_MAXIMIZE" states="3" />
-    <imglst name="btn_sys_restore" src="IDP_BTN_SYS_RESOTRE" states="3" />
-    
-    <imgframe name="skin_edit_border" src="IDP_BORDER_EDIT" states="2" left="2" top="2"/>
-    <button name="normalbtn" border="7D9EBC" bg="FBFCFD" bgup="FEFEFE"
-      bgdown="C6E2FD" bguphover="FEFEFE" bgdownhover="DBEDFE"
-      bguppush="C6E2FD" bgdownpush="FEFEFE"/>
-    
-    <imgframe name="skin_split_vert" src="IDP_SPLIT_VERT" top="20" bottom="10"/>
-    <imgframe name="skin_split_horz" src="IDP_SPLIT_HORZ" left="20" right="10"/>
-    <imgframe name="btn_yellow" src="IDP_BTN_YELLOW" left="3" states="4"/>
-    <imglst name="tabskin_default" src="IDP_TAB_COMMON" states="3"/>
-    <imgframe name="comboboxbtn" src="IDP_DROPBTN" states="3"/>
-
-  </skins>
-  
-  <style>
-    <class name="cls_dlg_frame" skin="dlg_frame" font="0000" crtext="FFFFFF" x-margin="0"/>
-
-    <class name="cls_btn_link"    cursor="hand" crhover="0A84D2" />
-    <!--å®ä¹æå­æé®çæ ·å¼-->
-    <class name="cls_btn_weblink" cursor="hand" crtext="1e78d5" crhover="1e78d5" hoverfont="0002" />
-
-    <class name="cls_txt_red"     font="0004:å®ä½"  crtext="FF0000" />
-    <!--å®ä¹ç½è²ç²ä½å®ä½-->
-    <class name="cls_txt_black"   font="0004:å®ä½"  crtext="000000" />
-    <!--å®ä¹é»è²ç²ä½å®ä½-->
-    <class name="cls_txt_white"   font="0004:å®ä½"  crtext="FFFFFF" />
-    <!--å®ä¹ç½è²ç²ä½å®ä½-->
-    <class name="Arial_txt_white_center"   font="0004:Arial" textmode="25" crtext="FFFFFF" />
-
-    <class name="normalbtn" skin="normalbtn" font="0000" crtext="385e8b" crdisabled="91a7c0" textmode="25" cursor="hand" x-margin="0"/>
-
-    <class name="toptext" textmode="20" />
-    <class name="vcentertext" textmode="24"/>
-    <class name="rightvcentertext" textmode="26"/>
-    <class name="centertext" textmode="25"/>
-    <class name="righttext" textmode="22"/>
-    <class name="Arial_txt_white"   font="0000:Arial" textmode="25" crtext="FCF5F1" />
-    <class name="Arial_txt_gray"   font="0000:Arial" textmode="25" crtext="565656" />
-
-    <class name="linkimage" cursor="hand"/>
-    <class name="cls_border" ncskin="skin_edit_border" x-margin="2" y-margin="2"/>
-  </style>
-
-  <objattr>
-    <button class="normalbtn"/>
-    <check skin="btncheckbox"/>
-    <radio skin="btnRadio"/>
-    <imgbtn class="linkimage"/>
-    <divex sbskin="sb_common" sbwid="16"/>
-    <edit transparent="1" class="cls_border"/>
-    <combobox class="cls_border"/>
-    <tabctrl tabskin="tabskin_default" crtext="000000" align="top" tabwidth="70" tabheight="38" tabspacing="0" tabpos="5" dotted="1"/>
-  </objattr>
-
-</DuiEngine>
\ No newline at end of file
+<DuiEngine>
+	<font face="å®ä½" size="12" />
+	<string>
+		<s id="1">SoUIEditor</s>
+		<s id="2">1.0</s>
+	</string>
+	<skins>
+		<imgframe name="dlg_frame" src="IDP_MAIN_DLG_FRAME" left="5" right="5" top="40" bottom="40" />
+		<imglst name="btncheckbox" src="IDP_BTN_WND_CHECKBOX" states="8" />
+		<imglst name="btnRadio" src="IDP_BTN_WND_RADIO" states="8" />
+		<imglst name="focuscheckbox" src="IDP_FOCUS_CHECK" />
+		<imglst name="focusRadio" src="IDP_FOCUS_RADIO" />
+		<scrollbar name="sb_common" src="IDP_SCROLL" margin="3" />
+		<imglst name="btn_sys_close" src="IDP_BTN_SYS_CLOSE" states="3" />
+		<imglst name="btn_sys_minimize" src="IDP_BTN_SYS_MINIMIZE" states="3" />
+		<imglst name="btn_sys_maximize" src="IDP_BTN_SYS_MAXIMIZE" states="3" />
+		<imglst name="btn_sys_restore" src="IDP_BTN_SYS_RESOTRE" states="3" />
+		<imgframe name="skin_edit_border" src="IDP_BORDER_EDIT" states="2" left="2" top="2" />
+		<button name="normalbtn" border="7D9EBC" bgup="FEFEFE" bgdown="C6E2FD" bguphover="FEFEFE" bgdownhover="DBEDFE" bguppush="C6E2FD" bgdownpush="FEFEFE" />
+		<imgframe name="skin_split_vert" src="IDP_SPLIT_VERT" top="20" bottom="10" />
+		<imgframe name="skin_split_horz" src="IDP_SPLIT_HORZ" left="20" right="10" />
+		<imgframe name="btn_yellow" src="IDP_BTN_YELLOW" left="3" states="4" />
+		<imglst name="tabskin_default" src="IDP_TAB_COMMON" states="3" />
+		<imgframe name="comboboxbtn" src="IDP_DROPBTN" states="3" />
+
+	</skins>
+	<style>
+		<class name="cls_dlg_frame" skin="dlg_frame" font="0000" crtext="FFFFFF" x-margin="0" />
+		<class name="cls_btn_link" cursor="hand" crhover="0A84D2" />
+		<class name="cls_btn_weblink" cursor="hand" crtext="1e78d5" crhover="1e78d5" hoverfont="0002" />
+		<class name="cls_txt_red" font="0004:å®ä½" crtext="FF0000" />
+		<class name="cls_txt_black" font="0004:å®ä½" crtext="000000" />
+		<class name="cls_txt_white" font="0004:å®ä½" crtext="FFFFFF" />
+		<class name="Arial_txt_white_center" font="0004:Arial" textmode="25" crtext="FFFFFF" />
+		<class name="normalbtn" skin="normalbtn" font="0000" crtext="385e8b" crdisabled="91a7c0" textmode="25" cursor="hand" x-margin="0" />
+		<class name="toptext" textmode="20" />
+		<class name="vcentertext" textmode="24" />
+		<class name="rightvcentertext" textmode="26" />
+		<class name="centertext" textmode="25" />
+		<class name="righttext" textmode="22" />
+		<class name="Arial_txt_white" font="0000:Arial" textmode="25" crtext="FCF5F1" />
+		<class name="Arial_txt_gray" font="0000:Arial" textmode="25" crtext="565656" />
+		<class name="linkimage" cursor="hand" />
+		<class name="cls_border" ncskin="skin_edit_border" x-margin="2" y-margin="2" />
+	</style>
+	<objattr>
+		<button class="normalbtn" />
+		<check skin="btncheckbox" />
+		<radio skin="btnRadio" />
+		<imgbtn class="linkimage" />
+		<divex sbskin="sb_common" sbwid="16" />
+		<edit transparent="1" class="cls_border" />
+		<combobox class="cls_border" />
+		<tabctrl tabskin="tabskin_default" crtext="000000" align="top" tabwidth="70" tabheight="38" tabspacing="0" tabpos="5" dotted="1" />
+	</objattr>
+</DuiEngine>
Index: SoUIEditor.cpp
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: SoUIEditor.vcproj
===================================================================
--- SoUIEditor.vcproj	(revision 127)
+++ SoUIEditor.vcproj	(working copy)
@@ -401,6 +401,30 @@
 				</File>
 			</Filter>
 		</Filter>
+		<Filter
+			Name="colorpicker"
+			>
+			<File
+				RelativePath=".\colorpicker\ColourPopup.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\colorpicker\ColourPopup.h"
+				>
+			</File>
+			<File
+				RelativePath=".\colorpicker\DuiColorPicker.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\colorpicker\DuiColorPicker.h"
+				>
+			</File>
+			<File
+				RelativePath=".\colorpicker\Tooltipctrl.h"
+				>
+			</File>
+		</Filter>
 		<File
 			RelativePath=".\ReadMe.txt"
 			>
Index: stdafx.h
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
